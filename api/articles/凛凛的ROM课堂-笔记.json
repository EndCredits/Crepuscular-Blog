{"title":"凛凛的ROM课堂 -- 笔记","uid":"f1ebc4ebc24f578a07f74f4230f839f5","slug":"凛凛的ROM课堂-笔记","date":"2022-09-26T04:23:24.000Z","updated":"2022-10-12T08:24:02.802Z","comments":true,"path":"api/articles/凛凛的ROM课堂-笔记.json","keywords":null,"cover":"https://avatars.githubusercontent.com/u/30337499?v=4","content":"<p>前一段 b 站直播凛凛没开麦… 斗胆加上一点点自己的理解，也记录一下自己做 rom 的一点点经验，算是为开源社区贡献一份自己微薄的力量</p>\n<h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><p>最基础的文件有以下几个 </p>\n<pre class=\"line-numbers language-vcs\" data-language=\"vcs\"><code class=\"language-vcs\">cce87ff thyme: Initial tree from lisa</code></pre>\n\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">ROOT\n|-Android.bp\n|-Android.mk\n|-AndroidProducts.mk\n|-BoardConfig.mk\n|-device.mk\n|-lineage_thyme.mk\n|-recovery\n| |-recovery.fstab\n|-rootdir\n| |-Android.mk\n| |-etc\n| | |-fstab.qcom\n| | |-init.recovery.qcom.rc</code></pre>\n\n<p>因为只是初始化了一个设备树的框架，所以比起 Github 上的成品 dt 会显得少很多东西，不要担心，之后我们会根据需要分别加入需要的部分</p>\n<h2 id=\"它们有什么用\"><a href=\"#它们有什么用\" class=\"headerlink\" title=\"它们有什么用?\"></a>它们有什么用?</h2><ul>\n<li><p>Android.bp</p>\n<p>  它定义了一个 soong namespace ，指向你的 dt ，至于什么是 soong namespace … 说来话长，可以理解为让 soong 编译系统能够发现你的 dt 以及里面配置的编译选项，它通常也会用于导入其他的 soong namespace，这样我们就可以选择编译导入的那个 namespace 里定义的模块，例如下面的这个例子，定义了自己的命名空间，以及导入了一个命名空间 <code>hardware/xiaomi</code></p>\n  <pre class=\"line-numbers language-blueprint\" data-language=\"blueprint\"><code class=\"language-blueprint\">soong_namespace &#123;\n    imports: [\n        &quot;hardware&#x2F;xiaomi&quot;,\n    ],\n&#125;</code></pre>\n</li>\n<li><p>Android.mk</p>\n<p>  主要用于 blueprint 还不成熟时，定义编译模块。它还会与 <code>make</code> 直接打交道，它通常至少有以下内容 ( 以 <code>picasso</code> 为例 )</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">LOCAL_PATH :&#x3D; $(call my-dir)\n\nifeq ($(TARGET_DEVICE),picasso)\n\ninclude $(call all-makefiles-under,$(LOCAL_PATH))\n\ninclude $(CLEAR_VARS)\n\nendif</code></pre>\n\n<p>  上面的内容告诉 <code>make</code> ，如果定义了 <code>picasso</code>，这个设备，那么调用当前目录下所有的 <code>Makefile</code> 来控制这个产品的编译。 <code>ifeq</code> 等等关键字是 Makefile 语法自带的关键字， <code>my-dir</code>, <code>all-makefiles-under</code>, 是 AOSP 为你预先写好的工具函数，简化你的工作，详细信息可以查阅 AOSP 的文档以及编译系统源代码，这些函数在整个编译系统以及我们设备的定义中会很常见</p>\n<p>  Android.mk 还有一个常见的用处就是可以创建一些 <code>symlink</code>，允许我们在编译时就把一些系统必要的挂载点创建好，这对一些服务的启动是必需的，例如 ( 以 <code>picasso</code> 为例 )</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># A&#x2F;B builds require us to create the mount points at compile time.\n# Just creating it for all cases since it does not hurt.\nFIRMWARE_MOUNT_POINT :&#x3D; $(TARGET_OUT_VENDOR)&#x2F;firmware_mnt\n$(FIRMWARE_MOUNT_POINT): $(LOCAL_INSTALLED_MODULE)\n @echo &quot;Creating $(FIRMWARE_MOUNT_POINT)&quot;\n @mkdir -p $(TARGET_OUT_VENDOR)&#x2F;firmware_mnt\n\nBT_FIRMWARE_MOUNT_POINT :&#x3D; $(TARGET_OUT_VENDOR)&#x2F;bt_firmware\n$(BT_FIRMWARE_MOUNT_POINT): $(LOCAL_INSTALLED_MODULE)\n @echo &quot;Creating $(BT_FIRMWARE_MOUNT_POINT)&quot;\n @mkdir -p $(TARGET_OUT_VENDOR)&#x2F;bt_firmware\n\nDSP_MOUNT_POINT :&#x3D; $(TARGET_OUT_VENDOR)&#x2F;dsp\n$(DSP_MOUNT_POINT): $(LOCAL_INSTALLED_MODULE)\n @echo &quot;Creating $(DSP_MOUNT_POINT)&quot;\n @mkdir -p $(TARGET_OUT_VENDOR)&#x2F;dsp\n\nALL_DEFAULT_INSTALLED_MODULES +&#x3D; $(FIRMWARE_MOUNT_POINT) $(BT_FIRMWARE_MOUNT_POINT) $(DSP_MOUNT_POINT)\n</code></pre>\n<p>  这里定义了 firmware 的挂载点，在编译初期你会看到</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">Creating xxxx mount point ...</code></pre>\n\n<p>  就是它们在起作用</p>\n<p>  对于高通设备，这些内容通常都可以在 CLO 对应的 Soc 仓库中找到</p>\n</li>\n<li><p>AndroidProducts.mk</p>\n<p>  它的作用是让你的设备能够被 AOSP 编译系统识别，也就是定义了你在使用 <code>lunch</code> 命令的时候，后面应该传递的参数，内容通常比较简单。</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">PRODUCT_MAKEFILES :&#x3D; \\\n    $(LOCAL_DIR)&#x2F;aosp_picasso.mk\n\nCOMMON_LUNCH_CHOICES :&#x3D; \\\n    aosp_picasso-userdebug \\\n    aosp_picasso-eng</code></pre>\n\n<p>  以前的编译系统还会用到 <code>add_lunch_combo</code> 这个函数，不过现在已经被弃用了，改成了定义 <code>COMMON_LUNCH_CHOICES</code> (如上代码框所示)</p>\n</li>\n<li><p>lineage_thyme.mk</p>\n<p>  这里定义了跟你设备有关的信息，比如它叫什么名字，是什么牌子的，编译它时应该继承哪些配置文件，特点是什么，GMS Client Base 等等，同样地，以编译我的 AOSP 的 <code>picasso</code> 为例</p>\n<p>  <code>aosp_picasso.mk</code></p>\n<p>  可以看到，这个文件的命名是有规律的，下划线前面的部分通常是你要编译的 rom 的代号，下划线后面的部分通常是你的设备代号，这个文件的名字应该与上面定义在 <code>AndroidProducts.mk</code> 里 <code>PRODUCT_MAKEFILES</code> 的名字一致</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Inherit from those products. Most specific first.\n$(call inherit-product, $(SRC_TARGET_DIR)&#x2F;product&#x2F;core_64_bit.mk)\n$(call inherit-product, $(SRC_TARGET_DIR)&#x2F;product&#x2F;full_base_telephony.mk)\n\n# Inherit from picasso device\n$(call inherit-product, device&#x2F;xiaomi&#x2F;picasso&#x2F;device.mk)\n\n# Inherit some common AOSP stuff.\n$(call inherit-product, vendor&#x2F;aosp&#x2F;config&#x2F;common.mk)\n\n# Add some Crepuscular AOSP Feature\nTARGET_SUPPORTS_QUICK_TAP :&#x3D; true\nTARGET_FACE_UNLOCK_SUPPORTED :&#x3D; true\nTARGET_INCLUDE_PIXEL_CHARGER :&#x3D; true\n\n# Device identifier. This must come after all inclusions.\nPRODUCT_NAME :&#x3D; aosp_picasso\nPRODUCT_DEVICE :&#x3D; picasso\nPRODUCT_MODEL :&#x3D; Redmi K30 5G\nPRODUCT_BRAND :&#x3D; Redmi\nPRODUCT_MANUFACTURER :&#x3D; Xiaomi\n\nTARGET_BOOT_ANIMATION_RES :&#x3D; 1080\n\nPRODUCT_GMS_CLIENTID_BASE :&#x3D; android-xiaomi</code></pre>\n<p>  英语好的同学应该已经可以明白上面的东西定义的是什么了，它们的名字比较直球的表示了它们的作用</p>\n<p>  首先是继承 AOSP 产品级配置文件</p>\n<p>  <code>$ANDROID_ROOT/build/make/target/product/core_64_bit.mk</code><br>  <code>$ANDROID_ROOT/build/make/target/product/full_base_telephony.mk</code></p>\n<p>  有兴趣的同学可以去查阅以下源代码它们到底定义了什么，总结一下就是集合了 Android 整个系统的绝大部分代码</p>\n<p>  然后就是继承你的设备配置文件</p>\n<p>  <code>$ANDROID_ROOT/device/xiaomi/picasso/device.mk</code></p>\n<p>  这个文件待会还会讲到，里面定义了什么 HAL 以及其他杂七杂八的必要组件应该被编译进你的系统</p>\n<p>  然后就是继承你的 rom 的配置文件，这里面通常包含了 ROM 特有的一些附加功能，以及一些对 AOSP 编译系统必要的补充，比如支持内核的编译等等</p>\n<p>  <code>$ANDROID_ROOT/vendor/aosp/config/common.mk</code></p>\n<p>  下面的就顾名思义就可以了，意义比较直球</p>\n</li>\n<li><p>BoardConfig.mk</p>\n<p>  比较重要的文件，定义了你的设备的所有的板级细节，这里也是凛凛着重讲解的一部分</p>\n<p>  代码比较多，我们分块来读 ( Dyncmic A-only 设备以 picasso 为例，AB 设备以 thyme 为例)</p>\n<p>  首先是架构体系相关的信息（ 同一个 platform 的设备这里可以直接抄，以 <code>picasso</code> 为例 ）</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Architecture\nTARGET_ARCH :&#x3D; arm64\nTARGET_ARCH_VARIANT :&#x3D; armv8-a\nTARGET_CPU_ABI :&#x3D; arm64-v8a\nTARGET_CPU_ABI2 :&#x3D;\nTARGET_CPU_VARIANT :&#x3D; cortex-a76\n\nTARGET_2ND_ARCH :&#x3D; arm\nTARGET_2ND_ARCH_VARIANT :&#x3D; armv8-a\nTARGET_2ND_CPU_ABI :&#x3D; armeabi-v7a\nTARGET_2ND_CPU_ABI2 :&#x3D; armeabi\nTARGET_2ND_CPU_VARIANT :&#x3D; cortex-a76</code></pre>\n\n<p>  这里定义了你的 Soc 是什么体系结构以及它所使用的变体，比如 <code>picasso</code> 是 <code>lito</code> 也就是 <code>sm7250</code> 平台，那么它的定义就是上面那个样子，如果你相关的平台还没有设备有设备树的话，那么这些信息去 Google 以下具体的 CPU 型号也都可以查的到</p>\n<p>  然后是 <code>bootloader</code> 的名字</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Bootloader\nTARGET_BOOTLOADER_BOARD_NAME :&#x3D; lito</code></pre>\n\n<p>  它定义了你的 Soc 的代号，可以通过这个命令查到</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">adb shell getprop ro.board.platform</code></pre>\n<p>  或者也可以像凛凛直播中讲的那样，去把它的信息 dump 出来然后翻 prop，来定义它，这里定义它的作用主要是为了编译一些跟你 Soc 相关的 HAL ，比如 <code>audio | display | media</code> 都会用到这个</p>\n<p>  下面是 <code>A/B</code> 机型特别所需的内容</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># A&#x2F;B\nAB_OTA_UPDATER :&#x3D; true\n\nAB_OTA_PARTITIONS +&#x3D; \\\n    boot \\\n    dtbo \\\n    odm \\\n    product \\\n    system \\\n    system_ext \\\n    vbmeta \\\n    vbmeta_system \\\n    vendor_boot \\\n    vendor</code></pre>\n\n\n<p>  上面的 <code>AB_OTA_UPDATER</code> 标志你的设备支持 AB 无缝系统更新， Legacy AB |  Dynamic AB | Virtual AB 都会需要这个，下面的 <code>AB_OTA_PARTITIONS</code> 定义了你的设备具有 AB 槽位的分区，这些分区会以 xxx_a 和 xxx_b 的形式出现在你的分区表里，你可以通过 <code>fastboot</code> 返回的信息确认你有哪些分区采用了 ab 架构</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">fastboot getvar all</code></pre>\n<p>  下面是内核的编译选项 (以 <code>picasso</code> 为例)</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Kernel\nBOARD_KERNEL_CMDLINE :&#x3D; console&#x3D;ttyMSM0,115200n8 androidboot.hardware&#x3D;qcom androidboot.console&#x3D;ttyMSM0 androidboot.memcg&#x3D;1 lpm_levels.sleep_disabled&#x3D;1 msm_rtb.filter&#x3D;0x237 service_locator.enable&#x3D;1 androidboot.usbcontroller&#x3D;a600000.dwc3 swiotlb&#x3D;2048 cgroup.memory&#x3D;nokmem,nosocket loop.max_part&#x3D;7 reboot&#x3D;panic_warm\nBOARD_KERNEL_CMDLINE +&#x3D; androidboot.init_fatal_reboot_target&#x3D;recovery\n# BOARD_KERNEL_CMDLINE +&#x3D; androidboot.selinux&#x3D;permissive\nBOARD_KERNEL_IMAGE_NAME :&#x3D; Image\nBOARD_BOOTIMG_HEADER_VERSION :&#x3D; 2\nBOARD_KERNEL_BASE :&#x3D; 0x00000000\nBOARD_KERNEL_PAGESIZE :&#x3D; 4096\nBOARD_KERNEL_SEPARATED_DTBO :&#x3D; true\nBOARD_MKBOOTIMG_ARGS +&#x3D; --header_version $(BOARD_BOOTIMG_HEADER_VERSION)\nTARGET_KERNEL_ADDITIONAL_FLAGS :&#x3D; DTC_EXT&#x3D;$(shell pwd)&#x2F;prebuilts&#x2F;misc&#x2F;$(HOST_OS)-x86&#x2F;dtc&#x2F;dtc\nTARGET_KERNEL_VERSION :&#x3D; 4.19\nTARGET_KERNEL_CLANG_COMPILE :&#x3D; true\nTARGET_KERNEL_SOURCE :&#x3D; kernel&#x2F;xiaomi&#x2F;sm7250\nTARGET_KERNEL_CONFIG :&#x3D; vendor&#x2F;picasso_user_defconfig\n</code></pre>\n\n<p>  内核编译是相对重要的一段，这里给出的实例是 oss kernel 的编译配置，prebuilt kernel 将会在下面给出</p>\n<p>  其中的 <code>BOARD_KERNEL_CMDLINE</code> 定义了传递给内核的可以理解为启动参数的命令行，这些当然不可能是我们默写出来的，它可以通过解包厂商 rom 里的 boot.img 得到，或者也可以通过 adb shell 查询</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">adb shell cat &#x2F;proc&#x2F;cmdline</code></pre>\n<p>  如果想要解包 boot 的话可以使用 unpackbootimg，使用方法可以查阅 <a href=\"https://github.com/anestisb/android-unpackbootimg\">anestisb&#x2F;android-unpackbootimg</a></p>\n<p>  或者提供一个更好解包工具集 <a href=\"https://github.com/ShivamKumarJha/android_tools\">ShivamKumarJha&#x2F;android_tools</a></p>\n<p>  然后是你的 <code>BOARD_KERNEL_IMAGE_NAME</code> ，这里定义了你的内核编译产物是什么，对于 4.19 平台，如果没有开启压缩的话，默认都是 <code>Image</code>，开启压缩可能是 <code>Image.gz</code>，对于 4.9 及以下的平台 ( 使用 bootheader v1 的设备 )，编译产物可能是 <code>Image.gz-dtb</code> 或者 <code>Image-dtb</code> ，它们的 dtb 附加在内核文件的后面，这一点可以查看你的内核 <code>defconfig</code> 是否开启了<code>CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE</code>，如果开启，那么就使用连接 dtb 的形式，如果没有开启这个而是开启了 <code>CONFIG_BUILD_ARM64_DT_OVERLAY</code>，说明你的 bootheader version 至少在 v2 及以上，那么就使用单独的 <code>Image</code> 形式</p>\n<p>  bootheader 版本也可以通过解包 boot.img 得到</p>\n<p>  关于 bootheader 的更多详细信息，请查阅: <a href=\"https://source.android.com/docs/core/architecture/bootloader/boot-image-header\">Boot Image Header - Android Open Source Project</a>，这里只做简单讲解，注意，以下直到讲解结束的 Android 版本均指设备出厂时的 Android 版本</p>\n<p>  Boot Image Header 定义了一系列 Android 引导加载程序所使用的标准，在 Android 9 之前，它属于 bootheader v0</p>\n  <pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">struct boot_img_hdr\n&#123;\n    uint8_t magic[BOOT_MAGIC_SIZE];\n    uint32_t kernel_size;                &#x2F;* size in bytes *&#x2F;\n    uint32_t kernel_addr;                &#x2F;* physical load addr *&#x2F;\n\n    uint32_t ramdisk_size;               &#x2F;* size in bytes *&#x2F;\n    uint32_t ramdisk_addr;               &#x2F;* physical load addr *&#x2F;\n\n    uint32_t second_size;                &#x2F;* size in bytes *&#x2F;\n    uint32_t second_addr;                &#x2F;* physical load addr *&#x2F;\n\n    uint32_t tags_addr;                  &#x2F;* physical addr for kernel tags *&#x2F;\n    uint32_t page_size;                  &#x2F;* flash page size we assume *&#x2F;\n    uint32_t unused;\n    uint32_t os_version;\n    uint8_t name[BOOT_NAME_SIZE];        &#x2F;* asciiz product name *&#x2F;\n    uint8_t cmdline[BOOT_ARGS_SIZE];\n    uint32_t id[8];                      &#x2F;* timestamp &#x2F; checksum &#x2F; sha1 &#x2F; etc *&#x2F;\n    uint8_t extra_cmdline[BOOT_EXTRA_ARGS_SIZE];\n&#125;;</code></pre>\n<p>  它有一个 <code>uint32_t</code> 类型的 <code>unused</code> 的保留字段</p>\n<p>  Android 9 正式支持了 bootheader 这一特性，其将保留字段更新为 <code>header_version</code> ，并新增了以下内容，该特性是 VTS 的强制要求</p>\n  <pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">struct boot_img_hdr\n&#123;\n    ...\n    uint32_t page_size;                  &#x2F;* flash page size we assume *&#x2F;\n    uint32_t header_version;\n    uint32_t os_version;\n    ...\n    uint32_t recovery_[dtbo|acpio]_size;    &#x2F;* size of recovery image *&#x2F;\n    uint64_t recovery_[dtbo|acpio]_offset;  &#x2F;* offset in boot image *&#x2F;\n    uint32_t header_size;               &#x2F;* size of boot image header in bytes *&#x2F;\n&#125;</code></pre>\n\n<p>  这时候设备就可以添加用于 recovery 的 dtbo | acpio 的内容了</p>\n<p>  在 Android 10 ， bootheader 更新到了 v2，添加了 dtb 相关信息的字段</p>\n  <pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">struct boot_img_hdr\n&#123;\n    ...\n    uint32_t header_size;               &#x2F;* size of boot image header in bytes *&#x2F;\n    uint32_t dtb_size;                  &#x2F;* size of dtb image *&#x2F;\n    uint64_t dtb_addr;                  &#x2F;* physical load address *&#x2F;\n&#125;;</code></pre>\n<p>  可以看到，这个时候 dtb 从内核上分离了出来，有了单独的存储区域，这也是为什么不再使用在内核后连接 dtb 的编译形式，<code>CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE</code> 也就不会被打开了</p>\n<p>  而 Android 11 ，bootheader 更新至 v3，改动较大</p>\n<ol>\n<li>移除了第二阶段引导加载程序的相关信息</li>\n<li>移除了 recovery 分区的相关信息</li>\n<li>移除了 dtb 的相关信息</li>\n</ol>\n  <pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">struct boot_img_hdr\n&#123;\n#define BOOT_MAGIC_SIZE 8\n    uint8_t magic[BOOT_MAGIC_SIZE];\n\n    uint32_t kernel_size;    &#x2F;* size in bytes *&#x2F;\n    uint32_t ramdisk_size;   &#x2F;* size in bytes *&#x2F;\n\n    uint32_t os_version;\n\n    uint32_t header_size;    &#x2F;* size of boot image header in bytes *&#x2F;\n    uint32_t reserved[4];\n    uint32_t header_version; &#x2F;* offset remains constant for version check *&#x2F;\n\n#define BOOT_ARGS_SIZE 512\n#define BOOT_EXTRA_ARGS_SIZE 1024\n    uint8_t cmdline[BOOT_ARGS_SIZE + BOOT_EXTRA_ARGS_SIZE];\n&#125;;</code></pre>\n\n<p>  这个时候，AB 设备中的 recovery 分区被合并进了 boot 分区，也就没有必要再指定 recovery 所使用的 dtbo | acpio，原本属于 bootheader 中的内容的 dtb 被放置到了 vendor_boot 分区中，所以也没有必要再放置有关 dtb 的信息</p>\n<p>  至于 vendor_boot ，是在 Android 11 中为兼容 GKI 而引入的新分区，所有 OEM 的修改都被分离到 vendor_boot 中，剩余部分使用 AOSP 通用内核的编译产物</p>\n<p>  而 A only 设备则只能止步于此，因为使用单独的 recovery 分区和 boot 分区，所以它们只能使用到 bootheader v2</p>\n<p>  到 Android 12 ， bootheader 更新至了 v4</p>\n  <pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">struct boot_img_hdr\n&#123;\n#define BOOT_MAGIC_SIZE 8\n    uint8_t magic[BOOT_MAGIC_SIZE];\n\n    uint32_t kernel_size;    &#x2F;* size in bytes *&#x2F;\n    uint32_t ramdisk_size;   &#x2F;* size in bytes *&#x2F;\n\n    uint32_t os_version;\n\n    uint32_t header_size;    &#x2F;* size of boot image header in bytes *&#x2F;\n    uint32_t reserved[4];\n    uint32_t header_version; &#x2F;* offset remains constant for version check *&#x2F;\n\n#define BOOT_ARGS_SIZE 512\n#define BOOT_EXTRA_ARGS_SIZE 1024\n    uint8_t cmdline[BOOT_ARGS_SIZE + BOOT_EXTRA_ARGS_SIZE];\n\n    uint32_t signature_size; &#x2F;* size in bytes *&#x2F;\n&#125;;</code></pre>\n\n<p>  新增了一个 <code>uint32_t</code> 类型的 <code>boot_signature</code> 字段，用于验证内核和 ramdisk 的完整性，但须注意的是，该字段并不参与 AVB 的启动过程而只由 VTS 测试使用</p>\n<p>  bootheader v4 同时还支持了分段的 vendor_boot 分区</p>\n<p>  关于 bootheader 的讨论到此结束，剩余部分请查阅 AOSP 项目文档</p>\n<p>  同理，上面中的 <code>BOARD_KERNEL_BASE</code> 和 <code>BOARD_KERNEL_PAGESIZE</code> 也可以从 <code>unpackbootimg</code> 中的输出信息中得到</p>\n<p>  事实上，像凛凛佬直播中使用的 <code>magiskboot</code> 程序会有更加良好的格式化以及更佳的可读性，同样也推荐使用</p>\n<p>  对于 <code>BOARD_KERNEL_SEPARATED_DTBO</code>，这个 flag 在有独立的 dtbo 分区的设备上是必须打开的，它控制编译系统是否支持以及编译单独的 dtbo 分区</p>\n<p>  而 <code>BOARD_MKBOOTIMG_ARGS</code> 则是在生成 <code>boot.img</code> 时，传递给 <code>mkbootimg</code> 程序的参数，比如上述参数</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">BOARD_MKBOOTIMG_ARGS +&#x3D; --header_version $(BOARD_BOOTIMG_HEADER_VERSION)</code></pre>\n<p>  意思就是给 <code>mkbootimg</code> 传入一个 –header_version 的参数，后面的是你的 bootheader version，已经在之前定义过了</p>\n<p>  下面的 <code>TARGET_KERNEL_ADDITIONAL_FLAGS</code> 则是在编译内核 <code>Image</code> 的时候，要传递给 <code>make</code> 程序的额外参数，比如上文中给出的</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">TARGET_KERNEL_ADDITIONAL_FLAGS :&#x3D; DTC_EXT&#x3D;$(shell pwd)&#x2F;prebuilts&#x2F;misc&#x2F;$(HOST_OS)-x86&#x2F;dtc&#x2F;dtc</code></pre>\n<p>  其中 <code>pwd</code> 指令是自己当前所在的目录，这样展开其实就是 <code>$ANDROID_ROOT/prebuilts/misc/linux-x86/dtc/dtc</code> 传入这一句的意思是向 <code>make</code> 程序说明，我们不希望使用内核源码中自带的 dtc ( device tree compiler | 内核设备树编译器 ) 编译内核的 dts，而是使用这个外部的预编译的 dtc ，这样做一方面是可以避免因为 dtc 版本不同而导致语法的不兼容，避免编译失败，也可以节约使用 HOSTCC 编译 dtc 的时间 ( 虽然说这个时间成本跟编译整个系统比起来要低很多就是了… )</p>\n<p>  有的时候我们还需要用这个 flag 来传递一些信息，比如我们可以传入</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">TARGET_KERNEL_ADDITIONAL_FLAGS +&#x3D; OBJDUMP&#x3D;llvm-objdump</code></pre>\n<p>  这一句的意思是我们想要使用 LLVM 的 <code>objdump</code> 程序而不是用 <code>gcc</code> 的</p>\n<p>  而最后面的三个 flag 就比较易懂了，它们的作用已经写在了它们的名字里</p>\n<p>  内核部分结束了，然后是分区的定义</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Metadata\nBOARD_USES_METADATA_PARTITION :&#x3D; true</code></pre>\n<p>  这个 flag 指定了你需不需要用 <code>metadata</code> 分区进行加密，现在采用 FBEv1&#x2F;v2 的机器基本上都会使用这个分区，同样地 <code>fastboot</code> 程序返回的数据里也会有关于这个分区的信息，视情况打开它就好</p>\n<p>  下面的是 oss vendor 所使用的分区信息<br>  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Partitions\nBOARD_BOOTIMAGE_PARTITION_SIZE :&#x3D; 134217728\nBOARD_CACHEIMAGE_PARTITION_SIZE :&#x3D; 402653184\nBOARD_DTBOIMG_PARTITION_SIZE :&#x3D; 33554432\nBOARD_RECOVERYIMAGE_PARTITION_SIZE :&#x3D; 134217728\nBOARD_USERDATAIMAGE_PARTITION_SIZE :&#x3D; 114919714816\n\nBOARD_SUPER_PARTITION_SIZE :&#x3D; 9126805504\nBOARD_SUPER_PARTITION_GROUPS :&#x3D; qti_dynamic_partitions\nBOARD_QTI_DYNAMIC_PARTITIONS_PARTITION_LIST :&#x3D; system system_ext product odm vendor\nBOARD_QTI_DYNAMIC_PARTITIONS_SIZE :&#x3D; 9122611200\n\nBOARD_FLASH_BLOCK_SIZE :&#x3D; 262144\n\nBOARD_CACHEIMAGE_FILE_SYSTEM_TYPE :&#x3D; ext4\nBOARD_ODMIMAGE_FILE_SYSTEM_TYPE :&#x3D; erofs\nBOARD_PRODUCTIMAGE_FILE_SYSTEM_TYPE :&#x3D; erofs\nBOARD_SYSTEM_EXTIMAGE_FILE_SYSTEM_TYPE :&#x3D; erofs\nBOARD_SYSTEMIMAGE_FILE_SYSTEM_TYPE :&#x3D; erofs\nBOARD_VENDORIMAGE_FILE_SYSTEM_TYPE :&#x3D; erofs\n\nBOARD_EROFS_PCLUSTER_SIZE :&#x3D; 65536\nBOARD_EROFS_USE_ZTAILPACKING :&#x3D; true\n\nTARGET_COPY_OUT_ODM :&#x3D; odm\nTARGET_COPY_OUT_PRODUCT :&#x3D; product\nTARGET_COPY_OUT_SYSTEM_EXT :&#x3D; system_ext\nTARGET_COPY_OUT_VENDOR :&#x3D; vendor</code></pre><br>  首先是第一组数据，定义了 <code>boot, cache, dtbo, recovery, userdata</code> 这几个分区的大小，这些属性同样也都会在你执行 <code>fastboot getvar all</code> 的时候悉数返回给你，只不过返回的值是 16 进制的，你需要用一些工具把它转换成 10 进制</p>\n<p>  第二组中，<code>BOARD_SUPER_PARTITION_SIZE</code> 定义了你的 super 分区的大小，获取方式同上，需要注意的是，只有在使用动态分区的设备上，第二块内容的定义才是必要的，否则如果没有使用动态分区，那么不需要定义 <code>DYNAMIC_PARTITIONS</code> 的相关属性</p>\n<p>  特别地，如果你的设备使用了 bootheader v3&#x2F;v4 并且拥有 <code>vendor_boot</code> 分区，那么你还需要定义 <code>BOARD_VENDOR_BOOT_PARTITIONS_SIZE</code> 这个 flag 来告诉编译系统 <code>vendor_boot</code> 分区的大小</p>\n<p>  其中还有一个 flag ，<code>BOARD_QTI_DYNAMIC_PARTITIONS_PARTITION_LIST</code> 定义了你的 super 分区中有哪些子分区，比如对于我们的 oss vendor 的编译需求，我们会需要去尽可能多的减少底包对我们的稳定性，所以我们需要将 super 分区里的全部内容都修改成我们需要的，也就是说我们编译我们需要的分区并且放进去，比如我们下面最后一组数据定义了我们会自行编译哪些分区的镜像，可以看到，有 <code> vendor product system_ext odm</code> 当然还有最重要的 <code>system</code> ，所以我们把它们写入动态分区的列表中，告诉编译系统，生成 super 分区镜像的时候需要把哪些子分区的镜像一起打包进去</p>\n<p>  而对于 prebuit vendor ，不需要编译那么多东西，通常只需要 <code>system product system_ext</code> 就可以了</p>\n<p>  至于名字为什么是 <code>QTI_DYNAMIC_PARTITIONS</code> ，这都不要紧，可以自己定义一个，比如上面 <code>BOARD_SUPER_PARTITION_GROUPS</code> flag 定义的是 <code>qti_dynamic_partitions</code> ，我可以改成 <code>picasso_dynamic_partitions</code>，只不过把所有的 <code>QTI_DYNAMIC_PARTITIONS</code> 都换成 <code>PICASSO_DYNAMIC_PARTITIONS</code> 就可以了</p>\n<p>  而对于 <code>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE</code> 的计算方法</p>\n<ul>\n<li>Virtual AB:  <code>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE</code> &#x3D; <code>BOARD_SUPER_PARTITION_SIZE</code> - <code>overhead</code></li>\n<li>AB: <code>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE</code> &#x3D; <code>BOARD_SUPER_PARTITION_SIZE</code> &#x2F; 2  - <code>overhead</code></li>\n<li>non-AB: <code>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE</code> &#x3D; <code>BOARD_SUPER_PARTITION_SIZE</code> - <code>overhead</code></li>\n</ul>\n<p>  其中 overhead 通常等于 4MB ，注意减去该值时需要将 MB 转化为 byte 才可以相减</p>\n<p>  下面的 <code>BOARD_FLASH_BLOCK_SIZE</code> 会定义在你的 boot.img 里，使用 <code>unpackbootimg</code> 工具可以看到这个值，它用于告诉 <code>fastboot</code> 它最大能一次刷入多少大小的东西，如果分区镜像文件的总大小超过了这个值，那就需要分步刷入，比如分成 7 次，每次刷入一点，这个值可以比 boot.img 中提取得到的值小，但绝对不能大，如果设置过大的话会导致无法刷入</p>\n<p>  第四组 flags 则是定义了你需要用什么样的分区格式，与 fstab 中的保持一致就好，需要注意的是，使用 <code>erofs</code> 文件系统需要内核支持，如若不支持请不要用 <code>erofs</code></p>\n<p>  最后一组就是定义了这些分区最终的编译产物的输出目录，copy 就好</p>\n<p>  然后是一些杂项</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Platform\nBOARD_USE_QCOM_HARDWARE :&#x3D; true\nTARGET_BOARD_PLATFORM :&#x3D; lito</code></pre>\n<p>  前一个比较明显，高通设备打开就好了，后面的那个跟你的 <code>TARGET_BOOTLOADER_BOARD_NAME</code> 保持一致就好了</p>\n<p>  然后是 Recovery 相关的配置</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; picasso: Recovery Section\n# Recovery\nBOARD_INCLUDE_DTB_IN_BOOTIMG :&#x3D; true\nBOARD_INCLUDE_RECOVERY_DTBO :&#x3D; true\nTARGET_RECOVERY_FSTAB :&#x3D; $(DEVICE_PATH)&#x2F;rootdir&#x2F;etc&#x2F;fstab.qcom\nTARGET_RECOVERY_PIXEL_FORMAT :&#x3D; &quot;BGRA_8888&quot;\nTARGET_USERIMAGES_USE_EXT4 :&#x3D; true\nTARGET_USERIMAGES_USE_F2FS :&#x3D; true\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n# Recovery\nBOARD_INCLUDE_RECOVERY_DTBO :&#x3D; true\nBOARD_USES_RECOVERY_AS_BOOT :&#x3D; true\nTARGET_NO_RECOVERY :&#x3D; true\nTARGET_RECOVERY_FSTAB :&#x3D; $(DEVICE_PATH)&#x2F;recovery&#x2F;recovery.fstab\nTARGET_RECOVERY_PIXEL_FORMAT :&#x3D; &quot;RGBX_8888&quot;\nTARGET_USERIMAGES_USE_EXT4 :&#x3D; true\nTARGET_USERIMAGES_USE_F2FS :&#x3D; true\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; thyme: Recovery Section</code></pre>\n\n<p>  可以看到差别不是很大，而且 flag 的名字也比较易懂，就只介绍 non-AB 和 AB 有什么异同点</p>\n<p>  对于 bootheader v2 及以上的具有独立 dtbo 分区的设备而言，<code>BOARD_INCLUDE_RECOVERY_DTBO</code> 需要打开，这一点 <code>picasso</code> 是 v2，<code>thyme</code> 是 v3，所以它们都启用了这个 flag，<code>BOARD_INCLUDE_DTB_IN_BOOTIMG</code> 在 <code>picasso</code> 的配置中打开了，但是 <code>thyme</code> 没有打开，原因可以参照前文的 bootheader v3 发生的变化，它的 dtb 不再包含在 boot 分区中，而是移动到了 <code>vendor_boot</code> 分区里，所以 <code>boot.img</code> 里是不含 dtb 的，然后就是 <code>BOARD_USES_RECOVERY_AS_BOOT</code> 和 <code>TARGET_NO_RECOVERY</code> ，同样地，这个时候 AB 分区的手机不再有独立的 recovery 分区，而是合并进了 boot 分区，所以 <code>thyme</code> 打开了这两个 flag 而 <code>picasso</code> 没有</p>\n<p>  下面介绍它们共有的 flags</p>\n<p>  首先是 <code>TARGET_RECOVERY_FSTAB</code> ，它指定了你的 recovery 在挂载分区的时候应该使用哪个 fstab ，可以看到这里 <code>picasso</code> 直接复用了编译进系统的 fstab ，而 <code>thyme</code> 则是单独摘了一个出来，都可以</p>\n<p>  然后是 <code>TARGET_RECOVERY_PIXEL_FORMAT</code>，它描述了你的 recovery 使用什么样的像素格式，像凛凛视频里那样介绍的拿取这个 flag 的值就好，或者也可以直接 copy 别的，影响不大</p>\n<p>  然后两个 flags 指定了你的 userdata 分区的格式，顾名思义即可</p>\n<p>  Android Verified Boot 的话… 直接去看 AOSP 的文档就好了，看看每一项都有什么作用</p>\n<p>  比较奇怪的一点是，在我翻源码的时候并没有找到传递给 <code>avbtool make_vbmeta_image</code> 的 <code>--flags</code> 标志位是什么含义，如果有人知道为什么要加上这个 <code>--flags 3</code> 的话请告诉我，十分感谢</p>\n<p>  BoardConfig.mk 的内容肯定不止有这一点点，之后我们还会再加入，以完善这个设备树</p>\n</li>\n<li><p>device.mk</p>\n<p>  这个文件里主要定义了你需要编译进系统里的各种软件包，库文件，配置文件等等，你的大部分精力基本上都是花在这些东西上的，下面来分解一下 prebuilt vendor 的内容</p>\n<p>  首先是 include 外部的 Makefile ，它们一般是这个格式</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Installs gsi keys into ramdisk, to boot a GSI with verified boot.\n$(call inherit-product, $(SRC_TARGET_DIR)&#x2F;product&#x2F;developer_gsi_keys.mk)</code></pre>\n<p>  需要注意的是凛凛直播中说到的 Updatable APEX ( 不是 APEX Legend !!! ) 我们使用 oss vendor 一般都不会打开，因为 ROM 优化的 jemalloc 或者 mimalloc 都在这里面， update 了之后就没了，而且在一些设备上还会造成 <code>bootloop</code>，所以这里不多提了，不过它是很好的虚拟化和容器化的例子，感兴趣的话可以学习一下</p>\n<p>  当然说 prebuilt 必须要加上这个，毕竟它 vendor 自带的 apex 多半是我们不能用的，所以要 update 成我们自己的</p>\n<p>  下面是 thyme 等 VAB 机型必须加入的内容</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Virtual A&#x2F;B\nENABLE_VIRTUAL_AB :&#x3D; ture\n$(call inherit-product, $(SRC_TARGET_DIR)&#x2F;product&#x2F;virtual_ab_ota.mk)</code></pre>\n<p>  意思比较一目了然，表明你的设备支持并使用了 Virtual A&#x2F;B 分区布局，如果不是 VAB 的话这里不需要加</p>\n<p>  然后是 Dalvik VM 堆内存的配置</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\"># Setup dalvik vm configs\n$(call inherit-product, frameworks&#x2F;native&#x2F;build&#x2F;phone-xhdpi-6144-dalvik-heap.mk)\n</code></pre>\n\n<p>  现代手机基本都是 6GB+ 了，所以直接用这个就好，然后的话对于老机型就去这个目录下找你对应的内存容量，加上就好了</p>\n<p>  然后是这个标记设备出厂时的 Android 版本的 flag</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Shipping API level\nPRODUCT_SHIPPING_API_LEVEL :&#x3D; 29</code></pre>\n\n<p>  是几就写几，特别重要不能写错，Android 版本与 API 版本的对应关系可以在 AOSP 文档里查到</p>\n<p>  然后就是 AB 系统更新的内容</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># A&#x2F;B\nAB_OTA_POSTINSTALL_CONFIG +&#x3D; \\\n    RUN_POSTINSTALL_system&#x3D;true \\\n    POSTINSTALL_PATH_system&#x3D;system&#x2F;bin&#x2F;otapreopt_script \\\n    FILESYSTEM_TYPE_system&#x3D;ext4 \\\n    POSTINSTALL_OPITIONAL_system&#x3D;true\n</code></pre>\n\n<p>  直接 copy 就好啦，不过要注意的是有的厂商会使用 erofs 或者别的文件系统 ，<code>FILESYSTEM_TYPE_system</code>要跟着一起变（ 最好 ) ，总之跟 fstab 中保持一致即可</p>\n<p>  然后设定启动动画的分辨率</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Boot animation\nTARGET_SCREEN_HEIGHT :&#x3D; 2400\nTARGET_SCREEN_WIDTH :&#x3D; 1080</code></pre>\n\n<p>  这就看你设备具体长宽是多少了，单位是像素</p>\n<p>  下面定义了你的 init 脚本配置</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Common init scripts\nPRODUCT_PACKAGES +&#x3D; \\\n    init.recovery.qcom.rc</code></pre>\n\n<p>  见凛凛 commit 里的内容，这是我们目前为止遇到的第一个 product package，也就是编译进你的设备的 “包” ，顺带提一嘴如何用 Android.mk 定义一个简单的模块，也就是所谓的 “包”</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> File: $DEVICE_PATH&#x2F;rootdir&#x2F;Android.mk</p></blockquote>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">include $(CLEAR_VARS)\nLOCAL_MODULE       :&#x3D; init.recovery.qcom.rc\nLOCAL_MODULE_TAGS  :&#x3D; optional\nLOCAL_MODULE_CLASS :&#x3D; ETC\nLOCAL_SRC_FILES    :&#x3D; etc&#x2F;init.recovery.qcom.rc\nLOCAL_MODULE_PATH  :&#x3D; $(TARGET_ROOT_OUT)\ninclude $(BUILD_PREBUILT)</code></pre>\n\n<p>  上面的字段中，首先是 include 了 <code>$(CLEAR_VARS)</code>，用于清除之前一个模块的配置信息 ( 比如前一个模块定义的 <code>LOCAL_MODULE</code> )，以免影响到我们这个模块的编译，然后是 <code>LOCAL_MODULE_CLASS</code> 定义了你这个模块所属的类，比如这个模块属于 ETC 类，后面的 <code>LOCAL_SRC_FILES</code> 则是定义了这个文件的具体位置 (相对于 Android.mk 的路径)，后面的 <code>LOCAL_MODULE_PATH</code> 定义了最后你的这个文件会被拷贝到哪里去，比如上文的这个模块，<code>init.recovery.qcom.rc</code> 就会被放置到 <code>$(TARGET_ROOT_OUT)</code> 这个位置，它是 AOSP 编译系统预先定义好的一组环境变量，用来告知编译系统你想把这个文件放到哪里，这里的意思就是放在 <code>root</code> 目录，其实对于 system-as-root 而言，也就是放进 system 里，以前的不使用 system-as-root 的机型可能会有 ramdisk，或者使用 2 Stage init 的设备也会有一个 ramdisk，最后就是 <code>include $(BUILD_PREBUILT)</code> ，它指明了你定义的这是个什么类型的文件，比如这个就是一个 prebuilt 文件，它决定了编译系统最后会怎么处置这个模块定义的源文件，它们也是 AOSP 编译系统预先定义的一组环境变量，可以去 build&#x2F;make 里查看</p>\n<p>  好的继续</p>\n<p>  上面 Common init scripts 字段中， <code>PRODUCT_PACKAGES</code> 定义了你需要将哪些包编译进系统，需要注意的是，这时候为这个变量赋值的时候必须使用 <code>+=</code> 运算符而不能使用 <code>:=</code>，使用后者会导致你原本的 <code>PRODUCT_PACKAGES</code> 被 override，这样很多软件包就丢了，毕竟这么大一个系统，不能只编译咱们定义的这几个 packages，所以上面那一句赋值的意思就是你想要多编译一个叫 <code>init.recovery.qcom.rc</code> 的包进入系统，加上这一句之后编译系统就会在它能访问的命名空间里找这个模块并且帮你编译进去，如果它找不到，它就会向你报错，告诉你这个模块它找不到，请君明鉴</p>\n<p>  然后是 fastbootd 的内容，fastbootd 是用户空间内的 fastboot 程序，用于操作 super 分区内的子分区，比如 system, vendor, system_ext 等等</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Fastbootd\nPRODUCT_PACKAGES +&#x3D; \\\n    fastbootd \\\n    android.hardware.fastboot@1.0-impl-mock</code></pre>\n\n<p>  之后的内容就比较简单了，只记录下 initial commit 的内容</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># F2FS utilities\nPRODUCT_PACKAGES +&#x3D; \\\n    sg_write_buffer \\\n    f2fs_io \\\n    check_f2fs \\\n\n# Partitions\nPRODUCT_BUILD_SUPER_PARTITION :&#x3D; false\nPRODUCT_USE_DYNAMIC_PARTITIONS :&#x3D; true\n\n# Soong namespace\nPRODUCT_SOONG_NAMESPACE :&#x3D; \\\n    $(LOCAL_PATH)\n\n# Update engine\nPRODUCT_PACKAGES +&#x3D; \\\n    otapreopt_script \\\n    update_engine \\\n    update_engine_sideload \\\n    update_verifier\n\nPRODUCT_PACKAGES_DEBUG +&#x3D; \\\n    update_engine_client\n\nPRODUCT_HOST_PACKAGES +&#x3D; \\\n    brillo_update_payload</code></pre>\n\n<p>  需要注意的是 Update engine 只有 A&#x2F;B 设备才会使用，Aonly 的设备不需要添加这些</p>\n<p>  然后是为 ramdisk 添加 fstab.qcom</p>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Vendor Boot\nPRODUCT_COPY_FILES +&#x3D; \\\n    $(LOCAL_PATH)&#x2F;rootdir&#x2F;etc&#x2F;fstab.qcom:$(TARGET_COPY_OUT_VENDOR_RAMDISK)&#x2F;first_stage_ramdisk&#x2F;fstab.qcom</code></pre>\n\n<p>  其中有些分区需要在第一阶段 init 的时候挂载，不然的话后续的系统加载流程找不到这些分区，系统就无法启动，对于 bootheader v3&#x2F;v4 使用 Virtual A&#x2F;B 分区布局的设备来说，我们需要把它拷贝到 <code>vendor_boot</code> 里的第一阶段 init 读取的目录，对于 A&#x2F;B 或者 non-A&#x2F;B 设备，我们只需要把它拷贝到第一阶段 ramdisk 里就好，比如你可以定义一下下面的模块</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$(DEVICE_PATH)&#x2F;rootdir&#x2F;Android.mk</p></blockquote>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">include $(CLEAR_VARS)\nLOCAL_MODULE       :&#x3D; fstab.qcom.ramdisk\nLOCAL_MODULE_STEM  :&#x3D; fstab.qcom\nLOCAL_MODULE_TAGS  :&#x3D; optional\nLOCAL_MODULE_CLASS :&#x3D; ETC\nLOCAL_SRC_FILES    :&#x3D; etc&#x2F;fstab.qcom\nLOCAL_MODULE_PATH  :&#x3D; $(TARGET_RAMDISK_OUT)\ninclude $(BUILD_PREBUILT)</code></pre>\n\n<p>  然后在 device.mk 里选择编译它</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$(DEVICE_PATH)&#x2F;device.mk</p></blockquote>\n  <pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Fstab\nPRODUCT_PACKAGES +&#x3D; \\\n    fstab.qcom.ramdisk</code></pre>\n\n<p>  后面凛凛直播的内容就是找文件了 (主要是 fstab) 和一个 init rc</p>\n<p>  基本的目录结构到这里就介绍完了</p>\n</li>\n</ul>\n<h2 id=\"后续工作\"><a href=\"#后续工作\" class=\"headerlink\" title=\"后续工作\"></a>后续工作</h2><p>其实凛凛在直播里说的很正确，前人已经踩过的坑就没有必要自己去踩一遍了，对于 bring up 新设备而言也是如此，找一个硬件跟你的手机差异不大的已经有 device tree 的机型做参考无疑是最佳的选择，这样可以少走很多弯路，使用它们的 commits ，然后自己去试着编译，哪里出问题了修哪里，修到最后，你的 device tree 也就大成了，在这个修的过程中你也会收获很多知识，得到很多经验，干这一块知识储备固然重要，但是经验也是很重要的，很多问题大佬看一眼就明白是哪里出了问题，是因为这个问题他遇到过了，他知道怎么去修复，或者他的知识储备很丰富，推断出这个问题可以怎么解决，对于高通设备而言，Soc 型号不一样甚至都没什么大问题，用同一个 tag ，需要的流程就基本一致，拿 lito 和 kona 举例子吧，它们都使用 SMxx50 的 tag，甚至 lito 的设备 inherit kona 的 common tree 做一点点然后编译就能开机</p>\n<h2 id=\"私有-blobs\"><a href=\"#私有-blobs\" class=\"headerlink\" title=\"私有 blobs\"></a>私有 blobs</h2><p>也就是凛凛直播中提到的第二个 commit</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>3a51ade thyme: Import extract utils</code></p></blockquote>\n<p>这个 commit 里提交了三个文件</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">extract-files.sh\nsetup-makefiles.sh\n\nproprietary-files.txt</code></pre>\n<p>这三个文件非常重要，它们协同工作，从厂商的 rom 里提取 blobs，生成了你的 vendor tree ，今后如果使用 oss vendor ，这三个文件更是重中之重</p>\n<p>上面的 <code>extract-files.sh</code> 会读取 <code>proprietary-files.txt</code> 中的文件，然后从你厂商的 rom dump 里一个一个的把它们揪出来，放进 <code>vendor/&lt;manufacturer&gt;/&lt;devicecodename&gt;</code> ，为什么要从厂商的 dump 里提取呢，因为它们是私有的二进制文件，不能从 AOSP&#x2F;CLO 源码里编译出来，所以我们必须使用它们来让一些 (实际上是几乎全部的) 硬件跑起来</p>\n<p>对于 prebuilt vendor， <code>proprietary-files.txt</code> 里的内容比较好搞，就直接 copy 那些内容，至于 oss vendor，放在之后补充</p>\n<p>凛凛的直播里说的很对的，不再赘述</p>\n<h2 id=\"vbmeta-与-dtbo\"><a href=\"#vbmeta-与-dtbo\" class=\"headerlink\" title=\"vbmeta 与 dtbo\"></a>vbmeta 与 dtbo</h2><p>接着就是下面一条 commit 的内容</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>61c5e31 thyme: releasetools: Ship and update vbmeta and dtbo images<br>76bfff7 thyme: releasetools: Add vbmeta_system to output zip</p></blockquote>\n<p>所谓 releasetools ，顾名思义，就是用来往你最终的那个 zip 里添加文件的一个 python 脚本，AOSP 编译系统默认不会把 dtbo 和 vbmeta 分区镜像添加进我们最终的 zip，所以我们需要自定义一下它来让它识别我们编译得到的这些镜像并把它们加入</p>\n<p>同样地，如果想要在编译 rom 的时候顺便把 firmware 更新一并做进去的话，靠的也是这个文件</p>\n<h2 id=\"SELinux\"><a href=\"#SELinux\" class=\"headerlink\" title=\"SELinux\"></a>SELinux</h2><p>接下来你要面对的是整个过程里最让你头疼没有之一的东西，SELinux</p>\n<p>Security-Enhanced Linux ，是 Linux MAC 权限控制框架下的一个基于标签的强制权限控制实现，由美国国家安全局 (NSA) 开发并开源，目的是为了增强 Linux 的安全性，限制程序对系统的修改，该组件自 Linux 2.6 被合并入 Linux 主线并于 Android 4.4 开始为 Android 提供全面保护</p>\n<p>上面说的那么好，为什么令人头疼呢，那就是因为它的权限控制策略配置，真的超级超级麻烦…</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>2048f0e thyme: include QCOM Sepolicy</p></blockquote>\n<pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Sepolicy\ninclude device&#x2F;qcom&#x2F;sepolicy&#x2F;SEPolicy.mk</code></pre>\n\n<p>Android 编译系统依赖 SELinux 上下文来确定每个文件的权限标签，不 include 它的话甚至编译都过不去，然后就是将 SELinux 设置为宽容模式</p>\n<pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">BOARD_KERNEL_CMDLINE +&#x3D; androidboot.selinux&#x3D;permissive</code></pre>\n<p>SELinux 会阻止所有未经策略配置允许的对系统资源的访问，如果让 SELinux 处于强制模式而你还没有配置好它的策略的话，它会阻止 Android 系统的正常启动，你是绝对开不了机的</p>\n<p>开机之后就需要配置 sepolicy，以便于日后的 enforcing，所有未经允许的访问 SELinux 都会通过 <code>logcat</code> 或者 <code>dmesg</code> 日志来告诉你，它的格式一般是</p>\n<pre class=\"line-numbers language-log\" data-language=\"log\"><code class=\"language-log\">09-23 20:44:39.878 19355:19355 W android.hardware.fingerprint@2.1-service_picasso: type&#x3D;1400 audit(0.0:410972): avc: denied &#123; create &#125; for name&#x3D;&quot;gf_data&quot; scontext&#x3D;u:r:hal_fingerprint_default:s0 tcontext&#x3D;u:object_r:system_data_root_file:s0 tclass&#x3D;dir permissive&#x3D;1</code></pre>\n<p>其中的 <code>&#123;&#125;</code> 里面的内容告诉了你是哪个操作被阻止了， <code>name</code> 的内容告诉你是什么东西发起了这个操作，<code>scontext</code> 的内容告诉你发起这个操作的程序的 selinux 上下文标签是什么，比如上面的例子里它的标签就叫 <code>hal_fingerprint_default</code>，然后 <code>tcontext</code> 的内容告诉你，被访问的目标的 selinux 上下文标签是什么，比如上面的例子里它是 <code>system_data_root_file</code>，后面的 <code>tclass</code> 标识了被访问的内容是什么东西，在这个例子里它是 <code>dir</code> ，也就是个目录，后面的 <code>permissive</code>标识当前 selinux 运行在什么模式下，比如这个例子里它运行在宽容模式下，那么 <code>permissive</code> 就是 1，如果它运行在 enforcing ( 强制 ) 模式下，那么它的值会变成 0</p>\n<p>你会得到一大堆像这种形式一样的报错，你的任务就是一个一个的去把它们解决掉然后添加策略… 是不是有点太麻烦了？？？</p>\n<p>不错，NSA 为我们提供了修复它的工具，<code>audit2allow</code>，详情可以直接查看 AOSP 文档，它会手把手的教你怎么用这个工具</p>\n<p>建议从导入一些别的机型的基本的 sepolicy 开始，比如 commit:</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>fb4d487 thyme: Initial sepolicy</code></p></blockquote>\n<h2 id=\"VINTF\"><a href=\"#VINTF\" class=\"headerlink\" title=\"VINTF\"></a>VINTF</h2><p>Vendor 接口对象，描述了你的设备中所有 HAL 的信息，以供编译时对 HAL 接口的检查以及运行时 <code>getTransport</code> 来找到各个 HAL 的接口入口 ( 当然如果它找不到的话就会报错你就开不了机XD )，同时它也是 CTS 测试的重要一部分</p>\n<p>对了.. 凛凛直播的时候可能是太紧张口误说错了一个地方，就是 HAL 它是硬件抽象层 ( Hardware Abstraction Layer ) 而不是硬件叠加层 ( Hardware Overlay Layer )，这两个概念是不同的，感兴趣的同学可以自己去查一查维基</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>2055f62 thyme: Import FCM from stock</code></p></blockquote>\n<p>整个 VINTF 体现在你 oss device tree 里其实有三个文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">manifests.xml\ncompatibility_matrixes.xml\nframework_compatibility_matrixes.xml</code></pre>\n\n<p>oss tree 稍后会再讲，嘛… 对于 prebuilt vendor 来说没那么麻烦，你就只需要一个 <code>framework_compatibility_matrixes.xml</code> 就足够了，这个文件是跟你 framework 里定义的 HAL 相关的，而对于你 device 自定义的 HAL 才需要上面的两个文件来描述它们，而这些 prebuilt vendor 都已经包含了，所以不需要</p>\n<p>从扩展名就可以看出， VINTF 配置文件采用 xml 语法，一般对于 <code>manifest.xml</code> 中的项来说，它们一般都像这样</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;hal format&#x3D;&quot;hidl&quot;&gt;\n    &lt;name&gt;android.hardware.biometrics.fingerprint&lt;&#x2F;name&gt;\n    &lt;transport&gt;hwbinder&lt;&#x2F;transport&gt;\n    &lt;version&gt;2.1&lt;&#x2F;version&gt;\n    &lt;interface&gt;\n        &lt;name&gt;IBiometricsFingerprint&lt;&#x2F;name&gt;\n        &lt;instance&gt;default&lt;&#x2F;instance&gt;\n    &lt;&#x2F;interface&gt;\n&lt;&#x2F;hal&gt;</code></pre>\n\n<ul>\n<li><code>name</code> 定义了一个 HAL 的名字</li>\n<li><code>transport</code> 定义了该 HAL 使用什么方式进行通信，对于 Android 9 之后 binderlized 的 HAL 而言一般都是 <code>hwbinder</code>，对于一些老的 HAL 它们通常是 <code>passthrough</code></li>\n<li><code>version</code> 标记了这个 HAL 的版本</li>\n<li><code>interface</code> 定义了这个 HAL 的接口，也就是 <code>getTransport</code> 需要的东西，这个接口可以有多个，比如下面 <code>vendor fingerprint hal</code> 的例子</li>\n<li><code>interface</code> -&gt; <code>name</code> 标记了一个接口的名称</li>\n<li><code>interface</code> -&gt; <code>instance</code> 标记了这个接口的实现，实现可以有多个</li>\n</ul>\n<p>这里<code>name</code> 和 <code>instance</code> 可以唯一确定一个接口，它们绝不会有重复</p>\n<p>这是一个 <code>Vendor Fingerprint HAL</code> 的例子</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;hal format&#x3D;&quot;hidl&quot;&gt;\n    &lt;name&gt;vendor.goodix.hardware.cap.biometrics.fingerprint&lt;&#x2F;name&gt;\n    &lt;transport&gt;hwbinder&lt;&#x2F;transport&gt;\n    &lt;version&gt;2.1&lt;&#x2F;version&gt;\n    &lt;interface&gt;\n        &lt;name&gt;IGoodixFingerprintDaemon&lt;&#x2F;name&gt;\n        &lt;instance&gt;default&lt;&#x2F;instance&gt;\n    &lt;&#x2F;interface&gt;\n    &lt;interface&gt;\n        &lt;name&gt;IGoodixFingerprintDaemonExt&lt;&#x2F;name&gt;\n        &lt;instance&gt;default&lt;&#x2F;instance&gt;\n    &lt;&#x2F;interface&gt;\n&lt;&#x2F;hal&gt;</code></pre>\n\n<p>可以看到 <code>interface</code>可以有多个，它也可以这么写</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;hal format&#x3D;&quot;hidl&quot;&gt;\n    &lt;name&gt;vendor.goodix.hardware.cap.biometrics.fingerprint&lt;&#x2F;name&gt;\n    &lt;transport&gt;hwbinder&lt;&#x2F;transport&gt;\n    &lt;fqname&gt;@2.1::IGoodixFingerprintDaemon&#x2F;default&lt;&#x2F;fqname&gt;\n    &lt;fqname&gt;@2.1::IGoodixFingerprintDaemonExt&#x2F;default&lt;&#x2F;fqname&gt;\n&lt;&#x2F;hal&gt;</code></pre>\n<p>用 <code>fqname</code> 可以简化写法，甚至可以定义不同接口多个版本，像下面 <code>Radio HAL</code> 的写法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;hal format&#x3D;&quot;hidl&quot;&gt;\n    &lt;name&gt;android.hardware.radio&lt;&#x2F;name&gt;\n    &lt;transport&gt;hwbinder&lt;&#x2F;transport&gt;\n    &lt;fqname&gt;@1.5::IRadio&#x2F;slot1&lt;&#x2F;fqname&gt;\n    &lt;fqname&gt;@1.5::IRadio&#x2F;slot2&lt;&#x2F;fqname&gt;\n    &lt;fqname&gt;@1.2::ISap&#x2F;slot1&lt;&#x2F;fqname&gt;\n    &lt;fqname&gt;@1.2::ISap&#x2F;slot2&lt;&#x2F;fqname&gt;\n&lt;&#x2F;hal&gt;</code></pre>\n\n<p>当然说具体应该写什么还得看系统给你报什么错，这个错误一般是由 <code>check_vintf_list</code> 在编译时报错以及 <code>hwservicemanager</code> 的  <code>getTransport</code> 在运行时报错，错一个修一个就可以</p>\n<p>不过一般也不用你来写，可以从 CLO 直接拿或者从 dump 里提取，用 find + grep 找它就好了</p>\n<h2 id=\"BootControl-HAL\"><a href=\"#BootControl-HAL\" class=\"headerlink\" title=\"BootControl HAL\"></a>BootControl HAL</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>77e9181 thyme: Import and Build bootctl from CAF</code></p></blockquote>\n<p>Boot Control HAL 是使用 A&#x2F;B 无缝系统更新的设备必须实现的 HAL ，它会接收来自系统 <code>update_engine</code> 的消息，选择启动时应该使用哪一个槽位，它实现了启动过程中的一个状态机，根据不同的情况进行不同的槽位选择</p>\n<p>使用 A&#x2F;B 无缝系统更新的设备 OEM 和 SoC 厂商必须确保 bootloader 已经按照要求实现了 bootcontrol hal 所需要的接口，这也是为什么 Google 的 boot control hal 我们没有办法直接用，因为这个跟 OEM 和 SoC 都有一定的关系，所以我们从 CAF ( 现在改名叫 CLO 了 ) 导入这个包含了高通特有修改的 bootctl 和 gpt-utils</p>\n<p>这一条 commit 对于使用 A&#x2F;B 系统更新的设备来说直接 pick 就好</p>\n<h2 id=\"Build-Flags\"><a href=\"#Build-Flags\" class=\"headerlink\" title=\"Build Flags\"></a>Build Flags</h2><p>这些 Build 过程中起作用标志位主要是为了打开一些编译系统默认已经弃用的功能，不想那么麻烦的话一股脑打开就好</p>\n<pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Build\nBUILD_BROKEN_DUP_RULES :&#x3D; true\nBUILD_BROKEN_ELF_PREBUILT_PRODUCT_COPY_FILES :&#x3D; true\nBUILD_BROKEN_VENDOR_PROPERTY_NAMESPACE :&#x3D; true\nBUILD_BROKEN_MISSING_REQUIRED_MODULES :&#x3D; true\nBUILD_BROKEN_ENFORCE_SYSPROP_OWNER :&#x3D; true</code></pre>\n<p>对于凛凛的那个 commit ，不加的话像这样的东西就会是 error 了</p>\n<pre class=\"line-numbers language-log\" data-language=\"log\"><code class=\"language-log\">build&#x2F;make&#x2F;core&#x2F;Makefile:72: warning: overriding commands for target &#96;&#x2F;home&#x2F;crepuscular&#x2F;Working&#x2F;home&#x2F;crepuscular&#x2F;development&#x2F;aosp&#x2F;out&#x2F;target&#x2F;product&#x2F;picasso&#x2F;vendor&#x2F;lib&#x2F;hw&#x2F;audio.primary.lito.so&#39;\nbuild&#x2F;make&#x2F;core&#x2F;base_rules.mk:533: warning: ignoring old commands for target &#96;&#x2F;home&#x2F;crepuscular&#x2F;Working&#x2F;home&#x2F;crepuscular&#x2F;development&#x2F;aosp&#x2F;out&#x2F;target&#x2F;product&#x2F;picasso&#x2F;vendor&#x2F;lib&#x2F;hw&#x2F;audio.primary.lito.so&#39;</code></pre>\n\n<h2 id=\"IMS-amp-amp-Telephony\"><a href=\"#IMS-amp-amp-Telephony\" class=\"headerlink\" title=\"IMS &amp;&amp; Telephony\"></a>IMS &amp;&amp; Telephony</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>e6d415f thyme: Compile IMS &amp; Telephony packages</code></p></blockquote>\n<p>这一条 commit 里的内容包含了编译 <code>IMS</code> 和 <code>Telephony</code> 功能的包，<code>IMS</code> 通常跟 VOLTE 有关，Telephony 嘛，顾名思义，接打电话用的，高通设备 pick 这条 commit 就好，对于 MTK 设备的话，还需要 phh 的 IMS 补丁集</p>\n<h2 id=\"Prebuilt-odm\"><a href=\"#Prebuilt-odm\" class=\"headerlink\" title=\"Prebuilt odm\"></a>Prebuilt odm</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>adc57bd thyme: Use prebuilt odm from stock</code></p></blockquote>\n<p>对于 prebuilt vendor 的设备需要原厂的 odm.img ，因为 vendor 里的东西会需要 odm 分区中的一些内容，如果我们编译的东西把它们覆盖掉了那就不好了，所以需要 prebuilt</p>\n<p>像这条 commit 里的 <code>THYME_PREBUILT</code> flag 是你自己定义的变量，不用这个也没事，你也可以在 dt 里放一个 prebuilt 文件夹，把 <code>odm.img</code> 放进去，然后 <code>BOARD_PREBUILT_ODMIMAGE</code> 对应的改成你的路径就好了，比如</p>\n<pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\">BOARD_PREBUILT_ODMIMAGE :&#x3D; $(LOCAL_PATH)&#x2F;prebuilt&#x2F;odm.img</code></pre>\n\n<p>对于上面的例子，之后就是记得在 <code>AB_OTA_PARTITION</code> 和 <code>BOARD_THYME_DYNAMIC_PARTITIONS_PARTITION_LIST</code> 里加上 odm 分区，让它一并被刷入就可以了</p>\n<h2 id=\"Overlay\"><a href=\"#Overlay\" class=\"headerlink\" title=\"Overlay\"></a>Overlay</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>d7f7f31 thyme: overlay: Import WifiRes overlay</code></p></blockquote>\n<p>严格意义上讲这里所说的 <code>overlay</code> 应该是特指 <code>Runtime Resource Overlay</code>，运行时资源叠加层，它的作用是在运行时改变某一个目标软件包的资源值，它可以覆盖原本源码里写死的值，替换成你想要的值，这对我们来说是非常有用的，因为一些功能的开启和关闭或者系统 UI 一些属性的定义 ( 比如挖孔样式 ) 都可以通过它来定义而没有必要每个设备都去修改一遍源码</p>\n<p>至于 <code>WifiResOverlay</code> 顾名思义，就是应用到 WIFI 相关软件包的资源叠加层，它的作用就是改变默认编译的 WIFI 软件包里某一些资源的值，来看这个例子</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$(DEVICE_PATH)&#x2F;overlay&#x2F;WifiResOverlayThyme&#x2F;AndroidManifest.xml</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;\n    package&#x3D;&quot;com.wifi.resources.thyme&quot;\n    android:verisonCode&#x3D;&quot;1&quot;\n    android:versionName&#x3D;&quot;1.0&quot;&gt;\n    &lt;application android:hasCode&#x3D;&quot;false&quot; &#x2F;&gt;\n    &lt;overlay android:targetPackage&#x3D;&quot;com.android.wifi.resources&quot;\n                   android:targetName&#x3D;&quot;WifiCustomization&quot;\n                   android:isStatic&#x3D;&quot;true&quot;\n                   android:priority&#x3D;&quot;0&quot; &#x2F;&gt;\n&lt;&#x2F;manifest&gt;</code></pre>\n\n<p>接触过 Android 应用开发的同学应该对上面的那个文件很熟悉，它定义了一个 Android 软件包</p>\n<ul>\n<li><p><code>manifest-&gt;package</code> 属性描述了这个 overlay 包的名字</p>\n</li>\n<li><p><code>manifest-&gt;android:versionCode</code> 属性描述了这个 overlay 包的版本</p>\n</li>\n<li><p><code>manifest-&gt;android:versionName</code> 属性描述了这个 overlay 包的版本名字</p>\n</li>\n<li><p><code>overlay-&gt;android:targetPackage=</code> 属性标示了这个 overlay 包要去覆盖哪个软件包 (包名) 的资源</p>\n</li>\n<li><p><code>overlay-&gt;android:targetName</code> 属性描述了你这个 overlay 的 target 是谁</p>\n</li>\n</ul>\n<p>重要的就是这些，其他的保持默认就好</p>\n<p>然后就是写入你想要覆盖的资源标签和内容，这些可以通过逆向厂商的 overlay 来获取，或者如果你自己有什么想法也可以往这里面加，同样遵循 xml 语法，厂商的 overlay 通常放在</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>/product/overlay/</code></p></blockquote>\n<p>去那里面把它们揪出来，然后用 <code>apktool d &lt;包&gt;</code> 或者 jadx 解包都可以，它们的资源文件就会全部暴露出来，放到你的 overlay 对应的目录中，在上面的例子里，它是</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>$(DEVICE_PATH)/overlay/WifiResOverlayThyme/res/values/</code></p></blockquote>\n<p>最后就是声明这个包是一个 overlay 并且在 device.mk 里编译它</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>$(DEVICE_PATH)/overlay/WifiResOverlayThyme/Android.bp</code></p></blockquote>\n<pre class=\"line-numbers language-blueprint\" data-language=\"blueprint\"><code class=\"language-blueprint\">runtime_resource_overlay &#123;\n    name: &quot;WifiResOverlayThyme&quot;,\n    theme: &quot;WifiResOverlayThyme&quot;,\n    certificate: &quot;platform&quot;,\n    sdk_version: &quot;current&quot;,\n    product_specific: true,\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>$(DEVICE_PATH)/device.mk</code></p></blockquote>\n<pre class=\"line-numbers language-Makefile\" data-language=\"Makefile\"><code class=\"language-Makefile\"># Overlays\nPRODUCT_PACKAGES +&#x3D; \\\n    WifiResOverlayThyme</code></pre>\n\n<p>加入其他的 overlay 方式也是一样的，有的时候一些 overlay 在你的厂商 overlay 里找不到的话可以去搜一下相近设备的 commit，如果有的话也可以直接采用</p>\n<p>另一种一些人比较熟悉的写法是 <code>Static Resource Overlay</code>，就是写在这种文件里的 overlay</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>overlay/frameworks/base/core/res/res/values/config.xml</code></p></blockquote>\n<p>这种静态资源叠加层不像 RRO 将会作为一个独立的 APK 编译进系统，而是会在编译时生效，去叠加源码中对应路径的资源值，最后你编译出来的这个源码组件就是你想要的样子，这有一个缺点就是对于那种大型组件比如 fwb 来说的话，整个重新来编译它耗时很长 ( 真的很长 )，而对于 RRO 来说，它只需要编译 RRO 的那个 APK 就可以了，好处是相对于 RRO 它的性能稍微好那么一点 ( 但也只有一点 ) ，相比之下如果性能不是那种非常非常吃紧的情况下用 RRO 会更加合算，而且这样也是 Google 推荐的做法</p>\n<h2 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h2><p>这些属性定义了 Android 中的一些特性是否开启或者关闭，对于 Prebuilt vendor 来说没有太麻烦，去 stock 的包里拿 build.prop 里的内容就好，而对于 oss vendor，因为自己魔改的自由度更大嘛，你就可以支持一些原本不支持的特性，关于每一条 prop 都有什么作用，可以直接去 Android Code Search 上搜索，源码中都有详细的注释</p>\n<h2 id=\"Init-Scripts\"><a href=\"#Init-Scripts\" class=\"headerlink\" title=\"Init Scripts\"></a>Init Scripts</h2><p>有一点点 Linux 基础的人都会知道这是干什么用的，不再赘述</p>\n<h2 id=\"Configs\"><a href=\"#Configs\" class=\"headerlink\" title=\"Configs\"></a>Configs</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>b6f9728: thyme: Import audio policy configuration from CAF</code></p></blockquote>\n<p>这些配置文件是 <code>AudioFlinger</code> 或者 <code>MediaProvider</code> 或者 <code>soundtrigger</code> 等系统服务需要的，比如 picasso 有这些配置文件</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$(DEVICE_PATH)&#x2F;audio</p></blockquote>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">audio_effects.xml\naudio_io_policy.conf\naudio_platform_info.xml\naudio_platform_info_intcodec.xml\naudio_platform_info_lagoon_qrd.xml\naudio_platform_info_qrd.xml\naudio_policy_configuration.xml\naudio_policy_volumes.xml\naudio_tuning_mixer.txt\nmixer_paths.xml\nmixer_paths_cdp.xml\nmixer_paths_lagoonmtp.xml\nmixer_paths_lagoonqrd.xml\nmixer_paths_mtp.xml\nmixer_paths_overlay_dynamic.xml\nmixer_paths_overlay_static.xml\nmixer_paths_qrd.xml\nsound_trigger_mixer_paths.xml\nsound_trigger_mixer_paths_cdp.xml\nsound_trigger_mixer_paths_lagoonmtp.xml\nsound_trigger_mixer_paths_lagoonqrd.xml\nsound_trigger_mixer_paths_qrd.xml\nsound_trigger_platform_info.xml</code></pre>\n\n<p>Audio 的配置文件通常用于配置 Audio 路由转发以及系统的各项音频相关策略，Media 通常包含了对于系统软硬件解码器以及其他媒体的细节的描述，这些都可以直接从 stock ROM 里拿，它们一般会被放置在</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>/vendor/etc</code></p></blockquote>\n<p>至于需要拿取哪些文件，对于 prebuilt vendor 而言其实一个 <code>audio_policy_configuration.xml</code> 一般就足够，剩下的使用 prebuilt vendor 里的，对于 oss vendor 而言，不如一股脑全放进去，至少绝对不会少不是嘛（）</p>\n<h2 id=\"vendor-overlay\"><a href=\"#vendor-overlay\" class=\"headerlink\" title=\"vendor overlay\"></a>vendor overlay</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>231cae0 thyme: Start using vendor overlay</code></p></blockquote>\n<p>prebuilt vendor，顾名思义，预编译的 vendor，我们不能直接修改 vendor 里的内容，我来多提两嘴这个 commit 有什么作用</p>\n<p>而 <code>vendor overlay</code> 允许你在设备启动时将变更叠加到 vendor 分区里，vendor overlay 是一系列放置在 <code>product</code> 分区的 vendor 模块 ( 比如各种运行库，可执行文件等 )，它们将在设备启动时替换或者添加 vendor 对应路径的文件</p>\n<p>当设备启动时，<code>init</code> 进程会完成第一阶段挂载并且读取默认的 props，然后 <code>init</code> 进程会读取 <code>/product/vendor_overlay/&lt;target_vendor_version&gt;</code>，并且把该目录的子目录挂载到 <code>vendor</code> 分区对应的路径下</p>\n<p>要使用 <code>vendor overlay</code> 时，需要满足下面的条件</p>\n<ul>\n<li><code>vendor</code> 分区中存在要被叠加的目标路径</li>\n<li><code>/product/vendor_overlay/&lt;target_vendor_version&gt;</code> 下要叠加到 <code>/vendor</code> 里的子目录 ( 或文件 ) 与 <code>/vendor</code> 对应的目录具有相同的 SELinux 文件上下文 ( file context )</li>\n<li><code>/vendor</code> 下目标目录的 selinux 文件上下文 ( file context ) 允许 <code>init</code> 挂载</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>! 注意，Vendor Overlay 可以替换，添加，但不可以删除 vendor 下的文件</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>! 使用 Vendor Overlay 同时需要你的内核支持 overlayfs ，并且内核版本至少在 4.4 以上</p></blockquote>\n<p>如果要使用 vendor overlay 的话， pick 上面的那条更改并且往 </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>/product/vendor_overlay/&lt;target_vendor_version&gt;</code> </p></blockquote>\n<p>下放置你想要 overlay 的文件就可以了，具体这条 commit 时怎么写出来的就是上面的三个条件，详情可以查阅 AOSP 的文档查看添加所用的示例</p>\n<p>而 oss vendor 不需要 vendor overlay ，因为 oss vendor 里面一部分的文件是我们用 AOSP&#x2F;CLO 源码编译进去的</p>\n<h2 id=\"Fingerprint\"><a href=\"#Fingerprint\" class=\"headerlink\" title=\"Fingerprint\"></a>Fingerprint</h2><p>可以考虑直接使用 prebuilt fingerprint hal ，或者对于屏下指纹可以使用 <code>hardware/xiaomi</code> 中的 common udsfps handler ，也就是修改过的 fingerprint hal 2.3，当然你可以自己来改，而侧边指纹通常是使用 fingerprint hal 2.1 ，导入之后自己修改即可，对于 sidefps 而言，通常是</p>\n<pre class=\"line-numbers language-log\" data-language=\"log\"><code class=\"language-log\">865a4e2 picasso: fingerprint: Add Xiaomi fingerprintextension support\nf0086ab picasso: fingerprint: Don&#39;t set ro.boot.fpsensor\n48bb127 picasso: Make fingerprint HIDL fully treble compliant\n157da0c picasso: Import fingerprint HIDL</code></pre>\n<p>对于 udsfp 的话，我没有做过，不敢说多，但是关于这方面的例子很多，都可以参考</p>\n<h2 id=\"Debug-调试\"><a href=\"#Debug-调试\" class=\"headerlink\" title=\"Debug 调试\"></a>Debug 调试</h2><p>对于 AOSP Bring up 过程中的调试，通常我们会用到两个东西</p>\n<h3 id=\"1-logcat\"><a href=\"#1-logcat\" class=\"headerlink\" title=\"1. logcat\"></a>1. logcat</h3><p>这是 AOSP 为我们提供的日志查看工具，可以输出 Android 各层输出的日志，有不同的日志输出级别，方便筛选信息，它通常是这个样子的</p>\n<pre class=\"line-numbers language-log\" data-language=\"log\"><code class=\"language-log\">08-19 23:03:43.941  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.wm.ActivityTaskManagerService$Lifecycle took to complete: 2ms\n08-19 23:03:43.941  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.am.ActivityManagerService$Lifecycle\n08-19 23:03:43.941  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.am.ActivityManagerService$Lifecycle took to complete: 0ms\n08-19 23:03:43.941  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.pm.DataLoaderManagerService\n08-19 23:03:43.941  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.pm.DataLoaderManagerService took to complete: 0ms\n08-19 23:03:43.941  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.power.PowerManagerService\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.power.PowerManagerService took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.power.ThermalManagerService\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.power.ThermalManagerService took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.power.hint.HintManagerService\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.power.hint.HintManagerService took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.recoverysystem.RecoverySystemService$Lifecycle\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.recoverysystem.RecoverySystemService$Lifecycle took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.lights.LightsService\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.lights.LightsService took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.display.DisplayManagerService\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.display.DisplayManagerService took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.pm.verify.domain.DomainVerificationService\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.pm.verify.domain.DomainVerificationService took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.pm.PackageInstallerService$Lifecycle\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.pm.PackageInstallerService$Lifecycle took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.pm.UserManagerService$LifeCycle\n08-19 23:03:43.942  1393  1730 V SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.pm.UserManagerService$LifeCycle took to complete: 0ms\n08-19 23:03:43.942  1393  1730 D SystemServerTimingAsync: ssm.onUnlockedUser-0_com.android.server.om.OverlayManagerService\n08-19 23:03:43.942  1393  1718 I AppWidgetServiceImpl: Processing of handleUserUnlocked u0 took 5 ms</code></pre>\n<p>它会提供给你很多信息</p>\n<p>如果你少了什么库，它通常会以 linker 或者 init 报错告诉你，格式是</p>\n<p>linker:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CANNOT LINK EXECTUABLE xxxx....</code></pre>\n\n<p>init:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">dlopen failed</code></pre>\n\n<p>遇到这种情况你就可以去 Github 上搜索这个库，然后决定是从源码编译出这个库来，还是去 stock 的 ROM 里提取，还是从别的机型 kang</p>\n<p>如果 HAL 因为 vintf 原因挂掉了，<code>hwservicemanager</code> 会向你报告错误，格式是</p>\n<pre class=\"line-numbers language-log\" data-language=\"log\"><code class=\"language-log\">hwservicemanager: getTransport: Cannot find entry &lt;hal name&gt;@&lt;version number&gt;::&lt;interface name&gt;&#x2F;&lt;interface instance&gt; in either framework or device VINTF manifest.</code></pre>\n\n<p>如果这个 HAL 压根都没有， <code>hwservicemanager</code> , <code>libc</code> , <code>HidlServiceManagement</code> , <code>init</code> 都会向你报错，格式是</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">09-29 08:47:05.673  3866  5249 W HidlServiceManagement: Waited one second for vendor.qti.data.factory@2.0::IFactory&#x2F;default\n09-29 08:47:05.673   608   608 I hwservicemanager: Since vendor.qti.data.factory@2.0::IFactory&#x2F;default is not registered, trying to start it as a lazy HAL.\n09-29 08:47:05.674  3866  5249 I HidlServiceManagement: getService: Trying again for vendor.qti.data.factory@2.0::IFactory&#x2F;default...\n09-29 08:47:05.676   608 20661 W libc    : Unable to set property &quot;ctl.interface_start&quot; to &quot;vendor.qti.data.factory@2.0::IFactory&#x2F;default&quot;: error code: 0x20\n09-29 08:47:05.676   608 20661 I hwservicemanager: Tried to start vendor.qti.data.factory@2.0::IFactory&#x2F;default as a lazy service, but was unable to. Usually this happens when a service is not installed, but if the service is intended to be used as a lazy service, then it may be configured incorrectly.\n07-23 02:03:50.894     0     0 E init    : Control message: Could not find &#39;vendor.qti.data.factory@2.0::IFactory&#x2F;default&#39; for ctl.interface_start from pid: 608 (&#x2F;system&#x2F;bin&#x2F;hwservicemanager)</code></pre>\n\n<p>如果系统里什么东西 crash 了，它会这样告诉你</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">09-14 12:03:02.155  7417  7417 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\n09-14 12:03:02.155  7417  7417 F DEBUG   : crDroid Version: &#39;9.0&#39;\n09-14 12:03:02.155  7417  7417 F DEBUG   : Build fingerprint: &#39;Xiaomi&#x2F;dipper&#x2F;dipper:8.1.0&#x2F;OPM1.171019.011&#x2F;V9.5.5.0.OEAMIFA:user&#x2F;release-keys&#39;\n09-14 12:03:02.155  7417  7417 F DEBUG   : Revision: &#39;0&#39;\n09-14 12:03:02.155  7417  7417 F DEBUG   : ABI: &#39;arm64&#39;\n09-14 12:03:02.155  7417  7417 F DEBUG   : Timestamp: 2022-09-14 12:03:02.019211249+0800\n09-14 12:03:02.155  7417  7417 F DEBUG   : Process uptime: 268s\n09-14 12:03:02.155  7417  7417 F DEBUG   : Cmdline: com.coolapk.market\n09-14 12:03:02.155  7417  7417 F DEBUG   : pid: 6936, tid: 6936, name: .coolapk.market  &gt;&gt;&gt; com.coolapk.market &lt;&lt;&lt;\n09-14 12:03:02.155  7417  7417 F DEBUG   : uid: 10257\n09-14 12:03:02.155  7417  7417 F DEBUG   : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0000000000000028\n09-14 12:03:02.155  7417  7417 F DEBUG   : Cause: null pointer dereference\n09-14 12:03:02.155  7417  7417 F DEBUG   :     x0  0000000000000000  x1  000000784208a5e0  x2  0000000000000200  x3  4c4d410100000000\n09-14 12:03:02.155  7417  7417 F DEBUG   :     x4  0000007840f56390  x5  0000000001414d4c  x6  0000000001414d4c  x7  0000007840f56004\n09-14 12:03:02.156  7417  7417 F DEBUG   :     x8  0000000000000001  x9  0000000000001b18  x10 0000000000001b18  x11 0000000000000000\n09-14 12:03:02.156  7417  7417 F DEBUG   :     x12 0037b99731b7b0b1  x13 0000000000000023  x14 0000007841f756d6  x15 000000000000000a\n09-14 12:03:02.156  7417  7417 F DEBUG   :     x16 0000000000000001  x17 000000784205ad40  x18 00000075ac0f3c0c  x19 0000000000000000\n09-14 12:03:02.156  7417  7417 F DEBUG   :     x20 0000007feb456204  x21 000000765c0a95d0  x22 0000007500516f73  x23 00000075ac0f89f0\n09-14 12:03:02.156  7417  7417 F DEBUG   :     x24 0000007840c7f000  x25 0000007500559000  x26 0000007840c7f000  x27 0000007500516f73\n09-14 12:03:02.156  7417  7417 F DEBUG   :     x28 0000000000000000  x29 000000762c0e3898\n09-14 12:03:02.156  7417  7417 F DEBUG   :     lr  000000750048c9a0  sp  0000007feb456180  pc  000000750048c9b0  pst 0000000000000000\n09-14 12:03:02.156  7417  7417 F DEBUG   : backtrace:\n09-14 12:03:02.156  7417  7417 F DEBUG   :       #00 pc 00000000000af9b0  [anon:.bss]</code></pre>\n<p>有时候就需要你自己判断该怎么去修了</p>\n<ol start=\"2\">\n<li>pstore</li>\n</ol>\n<p>pstore 是内核中用于实现调试的一个子系统，ramoops 会把控制台日志转储到一段特定的内存区域里，这部分内存不会被修改，不会断电丢失数据，在正常内核启动时，这部分数据会被挂载到 <code>/sys/fs/pstore</code> 下，这样你就可以知道 crash 的时候到底发生了什么，比如下面这个很经典的例子</p>\n<pre class=\"line-numbers language-log\" data-language=\"log\"><code class=\"language-log\">[    0.543742] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000002\n[    0.543746] Mem abort info:\n[    0.543748]   ESR &#x3D; 0x96000005\n[    0.543750]   Exception class &#x3D; DABT (current EL), IL &#x3D; 32 bits\n[    0.543752]   SET &#x3D; 0, FnV &#x3D; 0\n[    0.543754]   EA &#x3D; 0, S1PTW &#x3D; 0\n[    0.543756] Data abort info:\n[    0.543758]   ISV &#x3D; 0, ISS &#x3D; 0x00000005\n[    0.543761]   CM &#x3D; 0, WnR &#x3D; 0\n[    0.543763] [0000000000000002] user address but active_mm is swapper\n[    0.543767] Internal error: Oops: 96000005 [#1] PREEMPT SMP\n[    0.543770] Modules linked in:\n[    0.543774] Process swapper&#x2F;0 (pid: 1, stack limit &#x3D; 0x00000000a6b62718)\n[    0.543778] CPU: 7 PID: 1 Comm: swapper&#x2F;0 Tainted: G S                4.19.259-Driftwood #5\n[    0.543780] Hardware name: Qualcomm Technologies, Inc. 7250 picasso (DT)\n[    0.543783] pstate: 20c00005 (nzCv daif +PAN +UAO)\n[    0.543795] pc : inode_permission2+0x20&#x2F;0x180\n[    0.543798] lr : lookup_one_len_common+0x10c&#x2F;0x140\n[    0.543801] sp : ffffff800805b750\n[    0.543802] x29: ffffff800805b750 x28: 0000000000000078 \n[    0.543806] x27: ffffff98f2c5b1b8 x26: dead000000000200 \n[    0.543808] x25: fffffff7b687cc10 x24: ffffff98f36f2f10 \n[    0.543810] x23: fffffff7b6adf420 x22: ffffff98f36f2f10 \n[    0.543812] x21: fffffff7b6adf490 x20: 0000000000000000 \n[    0.543815] x19: 0000000000000001 x18: 00000000000001c2 \n[    0.543817] x17: 000000000000ba7e x16: 00000000000000e4 \n[    0.543819] x15: 000000000000ffff x14: 000074756f307065 \n[    0.543822] x13: 00000000fffffffe x12: ffffffffffffffff \n[    0.543824] x11: fffffff79949a270 x10: 000074756f307065 \n[    0.543827] x9 : df6191354b2a79c7 x8 : 0000000000000000 \n[    0.543830] x7 : 6e2f6f64fefefefe x6 : 0000808080808080 \n[    0.543832] x5 : 0000000000000000 x4 : ffffff800805b7a8 \n[    0.543835] x3 : 0000000000000000 x2 : 0000000000000001 \n[    0.543837] x1 : 0000000000000000 x0 : 0000000000000000 \n[    0.543840] Call trace:\n[    0.543843]  inode_permission2+0x20&#x2F;0x180\n[    0.543846]  lookup_one_len_common+0x10c&#x2F;0x140\n[    0.543849]  lookup_one_len_unlocked+0x38&#x2F;0x100\n[    0.543854]  debugfs_lookup+0x44&#x2F;0x70\n[    0.543865]  dwc3_gadget_free_endpoints+0x2c&#x2F;0xd0\n[    0.543868]  dwc3_gadget_exit+0x28&#x2F;0x140\n[    0.543872]  dwc3_remove+0x24&#x2F;0x100\n[    0.543876]  platform_drv_remove+0x24&#x2F;0x50\n[    0.543879]  device_release_driver_internal+0x16c&#x2F;0x230\n[    0.543881]  device_release_driver+0x14&#x2F;0x20\n[    0.543885]  bus_remove_device+0xd0&#x2F;0x100\n[    0.543888]  device_del+0x288&#x2F;0x580\n[    0.543890]  platform_device_unregister+0x2c&#x2F;0xb0\n[    0.543895]  of_platform_device_destroy+0xb4&#x2F;0xd0\n[    0.543897]  device_for_each_child+0x54&#x2F;0xb0\n[    0.543900]  of_platform_depopulate+0x30&#x2F;0x60\n[    0.543902]  dwc3_msm_probe+0xe10&#x2F;0xf10\n[    0.543905]  platform_drv_probe+0x7c&#x2F;0xc0\n[    0.543907]  really_probe+0x274&#x2F;0x300\n[    0.543909]  driver_probe_device+0x60&#x2F;0x100\n[    0.543911]  __driver_attach+0xcc&#x2F;0x110\n[    0.543915]  bus_for_each_dev+0x78&#x2F;0xc0\n[    0.543917]  driver_attach+0x20&#x2F;0x30\n[    0.543920]  bus_add_driver+0x11c&#x2F;0x200\n[    0.543923]  driver_register+0x74&#x2F;0x110\n[    0.543926]  __platform_driver_register+0x40&#x2F;0x50\n[    0.543928]  dwc3_msm_init+0x18&#x2F;0x20\n[    0.543932]  do_one_initcall+0x118&#x2F;0x280\n[    0.543937]  do_initcall_level+0x144&#x2F;0x16c\n[    0.543939]  do_basic_setup+0x30&#x2F;0x48\n[    0.543941]  kernel_init_freeable+0xc4&#x2F;0x144\n[    0.543945]  kernel_init+0x14&#x2F;0x290\n[    0.543947]  ret_from_fork+0x10&#x2F;0x20\n[    0.543951] Code: 2a0203f3 aa0103f4 aa0003e8 37080202 (79400689) \n[    0.543954] ---[ end trace f9c0eeb6e53bd0e4 ]---\n[    0.543971] Kernel panic - not syncing: Attempted to kill init! exitcode&#x3D;0x0000000b\n[    0.543971] \n[    0.543976] SMP: stopping secondary CPUs\n[    0.543986] devfreq_panic_callback: L3-DOMAIN\n[    0.543991]        PERF_STATE_DESIRED: 0x0000000b\n[    0.543994]             PSTATE_STATUS: 0xc44f03c4\n[    1.144083] ipa ipa3_active_clients_panic_notifier:305 \n[    1.144083] ---- Active Clients Table ----\n[    1.144083] \n[    1.144083] Total active clients count: 0\n[    1.144083] \n[    1.144090] Kernel Offset: 0x18e8800000 from 0xffffff8008000000\n[    1.144093] CPU features: 0x0000000c,a2802218\n[    1.144095] Memory Limit: none\n[    1.144099] Rebooting in 5 seconds..\n[    6.144528] SMP: stopping secondary CPUs\n[    6.144533] Going down for restart now</code></pre>\n\n<p>不过 prebuilt kernel 通常不会有这个，有的话基本就别想适配了（，所以这个主要是给 oss kernel 用的调试手段，在知道了是哪个函数 crash 之后，可以通过编译时生成的 <code>System.map</code> 来查询函数的具体地址，然后通过 <code>addr2line</code> 来查看到底是内核的哪一行出了问题</p>\n<p>寄存器信息也是很有用的，在 arm64 架构下，比较重要的寄存器有三个</p>\n<ul>\n<li>pc 寄存器: 即程序计数 ( Program Counter ) 寄存器，这个寄存器保存着 CPU 正在执行的指令的地址，addr2line 可以来找出这个地址对应了哪个函数，用于定位问题所在</li>\n<li>sp 寄存器: 即栈指针 ( Stack Pointer ) 寄存器，这个寄存器始终指向当前函数调用栈的栈顶，在 arm64 中, x0-x30 为通用寄存器，比如上面的日志，当前 x29 寄存器指向函数调用栈的栈顶，sp 寄存器的指向跟它一样</li>\n<li>lr 寄存器: 即连接 ( Linker ) 寄存器，存储了当前程序跳转后，原程序的下一条指令的地址</li>\n</ul>\n<h2 id=\"oss-vendor\"><a href=\"#oss-vendor\" class=\"headerlink\" title=\"oss vendor\"></a>oss vendor</h2><p>说了这么久终于到了 oss vendor 了，oss vendor 相较于 prebuilt vendor 的区别就是它里面的内容有一些是厂商私有的 blobs，还有一部分是我们自己从 AOSP&#x2F;CLO 编译的，因为 oss vendor 刷入时不像prebuilt vendor 不会修改原始 stock ，而是替换了整个 vendor 成我们自己的，这样做的好处是增加了我们的灵活性，可以灵活调整里面的 blobs，可以更新 HAL，可以更新二进制文件，可以适配新的 HAL，缺点就是十分麻烦，因为里面终究还是有私有的组件来确保你的设备能够正常运行，这些组件什么该加，什么不该加，HAL 需要编译什么，不需要编译什么，都由你来掌控，比较难以把握</p>\n<h3 id=\"再谈-proprietary-files-txt\"><a href=\"#再谈-proprietary-files-txt\" class=\"headerlink\" title=\"再谈 proprietary-files.txt\"></a>再谈 proprietary-files.txt</h3><p>前文中我们说到了这个文件的作用，我们发现，一些设备在 prebuilt vendor 下，这个文件不过几百行最多，但是一旦切换到了 oss vendor，这个文件马上就会有 1500 多行，这是为什么呢</p>\n<p>因为我们编译的 HAL 和二进制文件需要它们的支持，AOSP 源码编译出来的东西并不能满足我们设备的需要，这就需要厂商 blobs 出马，提供对我们设备的兼容性</p>\n<p>这里可以提供一点小小的经验关于这里到底应该添加什么东西以及从哪里找</p>\n<p>记得善用 <code>find</code> 和 <code>grep</code> 命令</p>\n<ol>\n<li>ACDB Data</li>\n</ol>\n<p>通常被放置在 </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>vendor/etc/acdbdata/</code> </p></blockquote>\n<p>下，用于承载 ADSP 服务，通常需要全部加入，有啥要啥，这一块主要管通话以及音频路由</p>\n<ol start=\"2\">\n<li>ACDB Loader</li>\n</ol>\n<p>ACDB 加载器，用于承载 ADSP 数据文件，它们通常有以下内容，以 <code>libacdb</code> 开头</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">vendor&#x2F;lib&#x2F;libacdb-fts.so\nvendor&#x2F;lib&#x2F;libacdbloader.so\nvendor&#x2F;lib&#x2F;libacdbrtac.so\nvendor&#x2F;lib64&#x2F;libacdb-fts.so\nvendor&#x2F;lib64&#x2F;libacdbloader.so\nvendor&#x2F;lib64&#x2F;libacdbrtac.so</code></pre>\n\n<ol start=\"3\">\n<li>ADSP</li>\n</ol>\n<p>高通 ADSP ( Audio DSP ) 服务，我这里就将它与 CDSP ( Compute DSP ) 分开了，它们通常具有以下文件名和路径特征</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vendor&#x2F;bin -&gt; &#123; adsprpc | dspservice | loadalgo&#125;\nvendor&#x2F;etc&#x2F;init -&gt; &#123; adscrpc-service.rc | hardware.dsp &#125;\nvendor&#x2F;etc&#x2F;seccomp_policy -&gt; &#123; hardware.dsp &#125;\nvendor&#x2F;lib -&gt; hardware.dsp\nvendor&#x2F;lib64 -&gt; &#123; hardware.dsp | libadsp | libloadalgo &#125;</code></pre>\n<p>用 find 找到它们，加入 proprietary-files 中就好了</p>\n<ol start=\"4\">\n<li>ADSP Modules</li>\n</ol>\n<p>高通 ADSP 服务模块，全部位于</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">vendor&#x2F;lib&#x2F;rfsa&#x2F;adsp\nvendor&#x2F;lib64&#x2F;rfsa&#x2F;adsp</code></pre>\n<p>这两个文件夹里所有的库全部加入</p>\n<ol start=\"5\">\n<li>Alarm</li>\n</ol>\n<p>关机 Alarm 驱动及其配置文件，位于</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;product&#x2F;app&#x2F;PowerOffAlarm\n&#x2F;system_ext&#x2F;framework&#x2F;\n&#x2F;vendor&#x2F;bin\n&#x2F;vendor&#x2F;bin&#x2F;hw\n&#x2F;vendor&#x2F;etc&#x2F;init\n&#x2F;vendor&#x2F;lib64\n&#x2F;vendor&#x2F;lib64&#x2F;hw</code></pre>\n\n<p>通常对应的 apk 叫做 PowerOffAlarm.apk，对应的二进制可执行文件叫做 power_off_alarm，其余的 Blobs 名字里都带 <code>hardware.alarm</code> 字段，find + grep 找它们就好</p>\n<ol start=\"6\">\n<li>ANT+</li>\n</ol>\n<p>ANT+ Wireless Service 驱动，</p>\n","feature":true,"text":"前一段 b 站直播凛凛没开麦… 斗胆加上一点点自己的理解，也记录一下自己做 rom 的一点点经验，算是为开源社区贡献一份自己微薄的力量 基本结构最基础的文件有以下几个 cce87ff thyme: Initial tree from lisa ROOT |-Android.bp ...","link":"","photos":[],"count_time":{"symbolsCount":"51k","symbolsTime":"47 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">基本结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">它们有什么用?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8E%E7%BB%AD%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">后续工作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89-blobs\"><span class=\"toc-text\">私有 blobs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vbmeta-%E4%B8%8E-dtbo\"><span class=\"toc-text\">vbmeta 与 dtbo</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SELinux\"><span class=\"toc-text\">SELinux</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#VINTF\"><span class=\"toc-text\">VINTF</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BootControl-HAL\"><span class=\"toc-text\">BootControl HAL</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Build-Flags\"><span class=\"toc-text\">Build Flags</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IMS-amp-amp-Telephony\"><span class=\"toc-text\">IMS &amp;&amp; Telephony</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Prebuilt-odm\"><span class=\"toc-text\">Prebuilt odm</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Overlay\"><span class=\"toc-text\">Overlay</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Props\"><span class=\"toc-text\">Props</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Init-Scripts\"><span class=\"toc-text\">Init Scripts</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Configs\"><span class=\"toc-text\">Configs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vendor-overlay\"><span class=\"toc-text\">vendor overlay</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Fingerprint\"><span class=\"toc-text\">Fingerprint</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Debug-%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">Debug 调试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-logcat\"><span class=\"toc-text\">1. logcat</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#oss-vendor\"><span class=\"toc-text\">oss vendor</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%8D%E8%B0%88-proprietary-files-txt\"><span class=\"toc-text\">再谈 proprietary-files.txt</span></a></li></ol></li></ol>","author":{"name":"Crepuscular Han","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/64133324","link":"/Crepuscular-Blog","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Happy birthday to my motherland -- China!","uid":"e1f04371a63c516375ead1ec5f4186b6","slug":"2022-Chinese-national-day","date":"2022-09-30T16:00:00.000Z","updated":"2022-10-12T08:24:02.800Z","comments":true,"path":"api/articles/2022-Chinese-national-day.json","keywords":null,"cover":"http://x0.ifengimg.com/res/2019/855A7E7B6D0AF80A577513EBE5DD64C969FFE6A9_size269_w600_h338.jpeg","text":" 人民有信仰 国家有力量 民族有希望 夏商周，春秋，战国，秦汉 | Xia, Shang, Zhou; Chunqiu; Zhanguo; Qin, Han. 三国，两晋，南北朝 | the Three dynasity; West Jin and East Jin; South...","link":"","photos":[],"count_time":{"symbolsCount":930,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Android","slug":"Android","count":1,"path":"api/tags/Android.json"}],"author":{"name":"Crepuscular Han","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/64133324","link":"/Crepuscular-Blog","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Build a Kernel for Redmi K30 5G by your self.","uid":"e20d5da4f42b631173f808fe36add280","slug":"Build-Kernel","date":"2022-07-19T16:00:00.000Z","updated":"2022-10-12T08:24:02.801Z","comments":true,"path":"api/articles/Build-Kernel.json","keywords":null,"cover":"https://camo.githubusercontent.com/b5d933cd654170ee36b79df0e26df2bc772efa7c36bd2644f8a1cd7744061f69/68747470733a2f2f66646e322e67736d6172656e612e636f6d2f76762f706963732f7869616f6d692f7869616f6d692d7265646d692d6b33302d35672d322e6a7067","text":"为自己的 Redmi K30 5G 编译一个 Linux 内核吧~ | 顺便记录一下自己编译内核的历程 1.系统软件包不同的系统需要不同的软件包，其实下面的软件包已经足以支撑整个 AOSP 的编译， Ubuntu&#x2F;Debian 系: sudo apt-get insta...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"Crepuscular Han","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/64133324","link":"/Crepuscular-Blog","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}