<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="前一段 b 站直播凛凛没开麦… 斗胆加上一点点自己的理解，也记录一下自己做 rom 的一点点经验，算是为开源社区贡献一份自己微薄的力量 基本结构最基础的文件有以下几个  1cce87ff thyme: Initial tree from lisa  1234567891011121314ROOT|-Android.bp|-Android.mk|-AndroidProducts.mk|-BoardC">
<meta property="og:type" content="article">
<meta property="og:title" content="凛凛的ROM课堂 -- 笔记">
<meta property="og:url" content="https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="Crepuscular&#39;s Blog">
<meta property="og:description" content="前一段 b 站直播凛凛没开麦… 斗胆加上一点点自己的理解，也记录一下自己做 rom 的一点点经验，算是为开源社区贡献一份自己微薄的力量 基本结构最基础的文件有以下几个  1cce87ff thyme: Initial tree from lisa  1234567891011121314ROOT|-Android.bp|-Android.mk|-AndroidProducts.mk|-BoardC">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-09-26T04:23:24.000Z">
<meta property="article:modified_time" content="2022-09-28T15:35:31.197Z">
<meta property="article:author" content="Crepuscular Hans">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/Crepuscular-Blog/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/Crepuscular-Blog/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/Crepuscular-Blog/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>凛凛的ROM课堂 -- 笔记</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/Crepuscular-Blog/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/Crepuscular-Blog/">Home</a></li><!--
     --><!--
       --><li><a href="/Crepuscular-Blog/about/">About</a></li><!--
     --><!--
       --><li><a href="/Crepuscular-Blog/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/EndCredits">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/Crepuscular-Blog/post/2022-Chinese-national-day.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/Crepuscular-Blog/post/Build-Kernel.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&text=凛凛的ROM课堂 -- 笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&is_video=false&description=凛凛的ROM课堂 -- 笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=凛凛的ROM课堂 -- 笔记&body=Check out this article: https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&name=凛凛的ROM课堂 -- 笔记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&t=凛凛的ROM课堂 -- 笔记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">它们有什么用?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">后续工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89-blobs"><span class="toc-number">4.</span> <span class="toc-text">私有 blobs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vbmeta-%E4%B8%8E-dtbo"><span class="toc-number">5.</span> <span class="toc-text">vbmeta 与 dtbo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SELinux"><span class="toc-number">6.</span> <span class="toc-text">SELinux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VINTF"><span class="toc-number">7.</span> <span class="toc-text">VINTF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BootControl-HAL"><span class="toc-number">8.</span> <span class="toc-text">BootControl HAL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Build-Flags"><span class="toc-number">9.</span> <span class="toc-text">Build Flags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IMS-amp-amp-Telephony"><span class="toc-number">10.</span> <span class="toc-text">IMS &amp;&amp; Telephony</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        凛凛的ROM课堂 -- 笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Crepuscular Hans</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-09-26T04:23:24.000Z" itemprop="datePublished">2022-09-26</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>前一段 b 站直播凛凛没开麦… 斗胆加上一点点自己的理解，也记录一下自己做 rom 的一点点经验，算是为开源社区贡献一份自己微薄的力量</p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>最基础的文件有以下几个 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vcs">cce87ff thyme: Initial tree from lisa<br></code></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">ROOT<br>|-Android.bp<br>|-Android.mk<br>|-AndroidProducts.mk<br>|-BoardConfig.mk<br>|-device.mk<br>|-lineage_thyme.mk<br>|-recovery<br>| |-recovery.fstab<br>|-rootdir<br>| |-Android.mk<br>| |-etc<br>| | |-fstab.qcom<br>| | |-init.recovery.qcom.rc<br></code></pre></td></tr></table></figure>

<p>因为只是初始化了一个设备树的框架，所以比起 Github 上的成品 dt 会显得少很多东西，不要担心，之后我们会根据需要分别加入需要的部分</p>
<h2 id="它们有什么用"><a href="#它们有什么用" class="headerlink" title="它们有什么用?"></a>它们有什么用?</h2><ul>
<li><p>Android.bp</p>
<p>  它定义了一个 soong namespace ，指向你的 dt ，至于什么是 soong namespace … 说来话长，可以理解为让 soong 编译系统能够发现你的 dt 以及里面配置的编译选项，它通常也会用于导入其他的 soong namespace，这样我们就可以选择编译导入的那个 namespace 里定义的模块，例如下面的这个例子，定义了自己的命名空间，以及导入了一个命名空间 <code>hardware/xiaomi</code></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs blueprint">soong_namespace &#123;<br>    imports: [<br>        &quot;hardware/xiaomi&quot;,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Android.mk</p>
<p>  主要用于 blueprint 还不成熟时，定义编译模块。它还会与 <code>make</code> 直接打交道，它通常至少有以下内容 ( 以 <code>picasso</code> 为例 )</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">LOCAL_PATH := <span class="hljs-variable">$(<span class="hljs-built_in">call</span> my-<span class="hljs-built_in">dir</span>)</span><br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(TARGET_DEVICE)</span>,picasso)<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(<span class="hljs-built_in">call</span> all-makefiles-under,<span class="hljs-variable">$(LOCAL_PATH)</span>)</span><br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(CLEAR_VARS)</span><br><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>

<p>  上面的内容告诉 <code>make</code> ，如果定义了 <code>picasso</code>，这个设备，那么调用当前目录下所有的 <code>Makefile</code> 来控制这个产品的编译。 <code>ifeq</code> 等等关键字是 Makefile 语法自带的关键字， <code>my-dir</code>, <code>all-makefiles-under</code>, 是 AOSP 为你预先写好的工具函数，简化你的工作，详细信息可以查阅 AOSP 的文档以及编译系统源代码，这些函数在整个编译系统以及我们设备的定义中会很常见</p>
<p>  Android.mk 还有一个常见的用处就是可以创建一些 <code>symlink</code>，允许我们在编译时就把一些系统必要的挂载点创建好，这对一些服务的启动是必需的，例如 ( 以 <code>picasso</code> 为例 )</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># A/B builds require us to create the mount points at compile time.</span><br><span class="hljs-comment"># Just creating it for all cases since it does not hurt.</span><br>FIRMWARE_MOUNT_POINT := <span class="hljs-variable">$(TARGET_OUT_VENDOR)</span>/firmware_mnt<br><span class="hljs-variable">$(FIRMWARE_MOUNT_POINT)</span>: <span class="hljs-variable">$(LOCAL_INSTALLED_MODULE)</span><br> @echo <span class="hljs-string">&quot;Creating <span class="hljs-variable">$(FIRMWARE_MOUNT_POINT)</span>&quot;</span><br> @mkdir -p <span class="hljs-variable">$(TARGET_OUT_VENDOR)</span>/firmware_mnt<br><br>BT_FIRMWARE_MOUNT_POINT := <span class="hljs-variable">$(TARGET_OUT_VENDOR)</span>/bt_firmware<br><span class="hljs-variable">$(BT_FIRMWARE_MOUNT_POINT)</span>: <span class="hljs-variable">$(LOCAL_INSTALLED_MODULE)</span><br> @echo <span class="hljs-string">&quot;Creating <span class="hljs-variable">$(BT_FIRMWARE_MOUNT_POINT)</span>&quot;</span><br> @mkdir -p <span class="hljs-variable">$(TARGET_OUT_VENDOR)</span>/bt_firmware<br><br>DSP_MOUNT_POINT := <span class="hljs-variable">$(TARGET_OUT_VENDOR)</span>/dsp<br><span class="hljs-variable">$(DSP_MOUNT_POINT)</span>: <span class="hljs-variable">$(LOCAL_INSTALLED_MODULE)</span><br> @echo <span class="hljs-string">&quot;Creating <span class="hljs-variable">$(DSP_MOUNT_POINT)</span>&quot;</span><br> @mkdir -p <span class="hljs-variable">$(TARGET_OUT_VENDOR)</span>/dsp<br><br>ALL_DEFAULT_INSTALLED_MODULES += <span class="hljs-variable">$(FIRMWARE_MOUNT_POINT)</span> <span class="hljs-variable">$(BT_FIRMWARE_MOUNT_POINT)</span> <span class="hljs-variable">$(DSP_MOUNT_POINT)</span><br><br></code></pre></td></tr></table></figure>
<p>  这里定义了 firmware 的挂载点，在编译初期你会看到</p>
  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Creating</span></span> xxxx mount point ...<br></code></pre></td></tr></table></figure>

<p>  就是它们在起作用</p>
<p>  对于高通设备，这些内容通常都可以在 CLO 对应的 Soc 仓库中找到</p>
</li>
<li><p>AndroidProducts.mk</p>
<p>  它的作用是让你的设备能够被 AOSP 编译系统识别，也就是定义了你在使用 <code>lunch</code> 命令的时候，后面应该传递的参数，内容通常比较简单。</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">PRODUCT_MAKEFILES := \<br>    <span class="hljs-variable">$(LOCAL_DIR)</span>/aosp_picasso.mk<br><br>COMMON_LUNCH_CHOICES := \<br>    aosp_picasso-userdebug \<br>    aosp_picasso-eng<br></code></pre></td></tr></table></figure>

<p>  以前的编译系统还会用到 <code>add_lunch_combo</code> 这个函数，不过现在已经被弃用了，改成了定义 <code>COMMON_LUNCH_CHOICES</code> (如上代码框所示)</p>
</li>
<li><p>lineage_thyme.mk</p>
<p>  这里定义了跟你设备有关的信息，比如它叫什么名字，是什么牌子的，编译它时应该继承哪些配置文件，特点是什么，GMS Client Base 等等，同样地，以编译我的 AOSP 的 <code>picasso</code> 为例</p>
<p>  <code>aosp_picasso.mk</code></p>
<p>  可以看到，这个文件的命名是有规律的，下划线前面的部分通常是你要编译的 rom 的代号，下划线后面的部分通常是你的设备代号，这个文件的名字应该与上面定义在 <code>AndroidProducts.mk</code> 里 <code>PRODUCT_MAKEFILES</code> 的名字一致</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Inherit from those products. Most specific first.</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> inherit-product, <span class="hljs-variable">$(SRC_TARGET_DIR)</span>/product/core_64_bit.mk)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> inherit-product, <span class="hljs-variable">$(SRC_TARGET_DIR)</span>/product/full_base_telephony.mk)</span><br><br><span class="hljs-comment"># Inherit from picasso device</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> inherit-product, device/xiaomi/picasso/device.mk)</span><br><br><span class="hljs-comment"># Inherit some common AOSP stuff.</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> inherit-product, vendor/aosp/config/common.mk)</span><br><br><span class="hljs-comment"># Add some Crepuscular AOSP Feature</span><br>TARGET_SUPPORTS_QUICK_TAP := true<br>TARGET_FACE_UNLOCK_SUPPORTED := true<br>TARGET_INCLUDE_PIXEL_CHARGER := true<br><br><span class="hljs-comment"># Device identifier. This must come after all inclusions.</span><br>PRODUCT_NAME := aosp_picasso<br>PRODUCT_DEVICE := picasso<br>PRODUCT_MODEL := Redmi K30 5G<br>PRODUCT_BRAND := Redmi<br>PRODUCT_MANUFACTURER := Xiaomi<br><br>TARGET_BOOT_ANIMATION_RES := 1080<br><br>PRODUCT_GMS_CLIENTID_BASE := android-xiaomi<br></code></pre></td></tr></table></figure>
<p>  英语好的同学应该已经可以明白上面的东西定义的是什么了，它们的名字比较直球的表示了它们的作用</p>
<p>  首先是继承 AOSP 产品级配置文件</p>
<p>  <code>$ANDROID_ROOT/build/make/target/product/core_64_bit.mk</code><br>  <code>$ANDROID_ROOT/build/make/target/product/full_base_telephony.mk</code></p>
<p>  有兴趣的同学可以去查阅以下源代码它们到底定义了什么，总结一下就是集合了 Android 整个系统的绝大部分代码</p>
<p>  然后就是继承你的设备配置文件</p>
<p>  <code>$ANDROID_ROOT/device/xiaomi/picasso/device.mk</code></p>
<p>  这个文件待会还会讲到，里面定义了什么 HAL 以及其他杂七杂八的必要组件应该被编译进你的系统</p>
<p>  然后就是继承你的 rom 的配置文件，这里面通常包含了 ROM 特有的一些附加功能，以及一些对 AOSP 编译系统必要的补充，比如支持内核的编译等等</p>
<p>  <code>$ANDROID_ROOT/vendor/aosp/config/common.mk</code></p>
<p>  下面的就顾名思义就可以了，意义比较直球</p>
</li>
<li><p>BoardConfig.mk</p>
<p>  比较重要的文件，定义了你的设备的所有的板级细节，这里也是凛凛着重讲解的一部分</p>
<p>  代码比较多，我们分块来读 ( Dyncmic A-only 设备以 picasso 为例，AB 设备以 thyme 为例)</p>
<p>  首先是架构体系相关的信息（ 同一个 platform 的设备这里可以直接抄，以 <code>picasso</code> 为例 ）</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Architecture</span><br>TARGET_ARCH := arm64<br>TARGET_ARCH_VARIANT := armv8-a<br>TARGET_CPU_ABI := arm64-v8a<br>TARGET_CPU_ABI2 :=<br>TARGET_CPU_VARIANT := cortex-a76<br><br>TARGET_2ND_ARCH := arm<br>TARGET_2ND_ARCH_VARIANT := armv8-a<br>TARGET_2ND_CPU_ABI := armeabi-v7a<br>TARGET_2ND_CPU_ABI2 := armeabi<br>TARGET_2ND_CPU_VARIANT := cortex-a76<br></code></pre></td></tr></table></figure>

<p>  这里定义了你的 Soc 是什么体系结构以及它所使用的变体，比如 <code>picasso</code> 是 <code>lito</code> 也就是 <code>sm7250</code> 平台，那么它的定义就是上面那个样子，如果你相关的平台还没有设备有设备树的话，那么这些信息去 Google 以下具体的 CPU 型号也都可以查的到</p>
<p>  然后是 <code>bootloader</code> 的名字</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Bootloader</span><br>TARGET_BOOTLOADER_BOARD_NAME := lito<br></code></pre></td></tr></table></figure>

<p>  它定义了你的 Soc 的代号，可以通过这个命令查到</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell getprop ro.board.platform<br></code></pre></td></tr></table></figure>
<p>  或者也可以像凛凛直播中讲的那样，去把它的信息 dump 出来然后翻 prop，来定义它，这里定义它的作用主要是为了编译一些跟你 Soc 相关的 HAL ，比如 <code>audio | display | media</code> 都会用到这个</p>
<p>  下面是 <code>A/B</code> 机型特别所需的内容</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># A/B</span><br>AB_OTA_UPDATER := true<br><br>AB_OTA_PARTITIONS += \<br>    boot \<br>    dtbo \<br>    odm \<br>    product \<br>    system \<br>    system_ext \<br>    vbmeta \<br>    vbmeta_system \<br>    vendor_boot \<br>    vendor<br></code></pre></td></tr></table></figure>


<p>  上面的 <code>AB_OTA_UPDATER</code> 标志你的设备支持 AB 无缝系统更新， Legacy AB |  Dynamic AB | Virtual AB 都会需要这个，下面的 <code>AB_OTA_PARTITIONS</code> 定义了你的设备具有 AB 槽位的分区，这些分区会以 xxx_a 和 xxx_b 的形式出现在你的分区表里，你可以通过 <code>fastboot</code> 返回的信息确认你有哪些分区采用了 ab 架构</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fastboot getvar all<br></code></pre></td></tr></table></figure>
<p>  下面是内核的编译选项 (以 <code>picasso</code> 为例)</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Kernel</span><br>BOARD_KERNEL_CMDLINE := console=ttyMSM0,115200n8 androidboot.hardware=qcom androidboot.console=ttyMSM0 androidboot.memcg=1 lpm_levels.sleep_disabled=1 msm_rtb.filter=0x237 service_locator.enable=1 androidboot.usbcontroller=a600000.dwc3 swiotlb=2048 cgroup.memory=nokmem,nosocket loop.max_part=7 reboot=panic_warm<br>BOARD_KERNEL_CMDLINE += androidboot.init_fatal_reboot_target=recovery<br><span class="hljs-comment"># BOARD_KERNEL_CMDLINE += androidboot.selinux=permissive</span><br>BOARD_KERNEL_IMAGE_NAME := Image<br>BOARD_BOOTIMG_HEADER_VERSION := 2<br>BOARD_KERNEL_BASE := 0x00000000<br>BOARD_KERNEL_PAGESIZE := 4096<br>BOARD_KERNEL_SEPARATED_DTBO := true<br>BOARD_MKBOOTIMG_ARGS += --header_version <span class="hljs-variable">$(BOARD_BOOTIMG_HEADER_VERSION)</span><br>TARGET_KERNEL_ADDITIONAL_FLAGS := DTC_EXT=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>/prebuilts/misc/<span class="hljs-variable">$(HOST_OS)</span>-x86/dtc/dtc<br>TARGET_KERNEL_VERSION := 4.19<br>TARGET_KERNEL_CLANG_COMPILE := true<br>TARGET_KERNEL_SOURCE := kernel/xiaomi/sm7250<br>TARGET_KERNEL_CONFIG := vendor/picasso_user_defconfig<br><br></code></pre></td></tr></table></figure>

<p>  内核编译是相对重要的一段，这里给出的实例是 oss kernel 的编译配置，prebuilt kernel 将会在下面给出</p>
<p>  其中的 <code>BOARD_KERNEL_CMDLINE</code> 定义了传递给内核的可以理解为启动参数的命令行，这些当然不可能是我们默写出来的，它可以通过解包厂商 rom 里的 boot.img 得到，或者也可以通过 adb shell 查询</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell <span class="hljs-built_in">cat</span> /proc/cmdline<br></code></pre></td></tr></table></figure>
<p>  如果想要解包 boot 的话可以使用 unpackbootimg，使用方法可以查阅 <a target="_blank" rel="noopener" href="https://github.com/anestisb/android-unpackbootimg">anestisb&#x2F;android-unpackbootimg</a></p>
<p>  或者提供一个更好解包工具集 <a target="_blank" rel="noopener" href="https://github.com/ShivamKumarJha/android_tools">ShivamKumarJha&#x2F;android_tools</a></p>
<p>  然后是你的 <code>BOARD_KERNEL_IMAGE_NAME</code> ，这里定义了你的内核编译产物是什么，对于 4.19 平台，如果没有开启压缩的话，默认都是 <code>Image</code>，开启压缩可能是 <code>Image.gz</code>，对于 4.9 及以下的平台 ( 使用 bootheader v1 的设备 )，编译产物可能是 <code>Image.gz-dtb</code> 或者 <code>Image-dtb</code> ，它们的 dtb 附加在内核文件的后面，这一点可以查看你的内核 <code>defconfig</code> 是否开启了<code>CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE</code>，如果开启，那么就使用连接 dtb 的形式，如果没有开启这个而是开启了 <code>CONFIG_BUILD_ARM64_DT_OVERLAY</code>，说明你的 bootheader version 至少在 v2 及以上，那么就使用单独的 <code>Image</code> 形式</p>
<p>  bootheader 版本也可以通过解包 boot.img 得到</p>
<p>  关于 bootheader 的更多详细信息，请查阅: <a target="_blank" rel="noopener" href="https://source.android.com/docs/core/architecture/bootloader/boot-image-header">Boot Image Header - Android Open Source Project</a>，这里只做简单讲解，注意，以下直到讲解结束的 Android 版本均指设备出厂时的 Android 版本</p>
<p>  Boot Image Header 定义了一系列 Android 引导加载程序所使用的标准，在 Android 9 之前，它属于 bootheader v0</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> magic[BOOT_MAGIC_SIZE];<br>    <span class="hljs-type">uint32_t</span> kernel_size;                <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-type">uint32_t</span> kernel_addr;                <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-type">uint32_t</span> ramdisk_size;               <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-type">uint32_t</span> ramdisk_addr;               <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-type">uint32_t</span> second_size;                <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-type">uint32_t</span> second_addr;                <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-type">uint32_t</span> tags_addr;                  <span class="hljs-comment">/* physical addr for kernel tags */</span><br>    <span class="hljs-type">uint32_t</span> page_size;                  <span class="hljs-comment">/* flash page size we assume */</span><br>    <span class="hljs-type">uint32_t</span> unused;<br>    <span class="hljs-type">uint32_t</span> os_version;<br>    <span class="hljs-type">uint8_t</span> name[BOOT_NAME_SIZE];        <span class="hljs-comment">/* asciiz product name */</span><br>    <span class="hljs-type">uint8_t</span> cmdline[BOOT_ARGS_SIZE];<br>    <span class="hljs-type">uint32_t</span> id[<span class="hljs-number">8</span>];                      <span class="hljs-comment">/* timestamp / checksum / sha1 / etc */</span><br>    <span class="hljs-type">uint8_t</span> extra_cmdline[BOOT_EXTRA_ARGS_SIZE];<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>  它有一个 <code>uint32_t</code> 类型的 <code>unused</code> 的保留字段</p>
<p>  Android 9 正式支持了 bootheader 这一特性，其将保留字段更新为 <code>header_version</code> ，并新增了以下内容，该特性是 VTS 的强制要求</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br>    <span class="hljs-type">uint32_t</span> page_size;                  <span class="hljs-comment">/* flash page size we assume */</span><br>    <span class="hljs-type">uint32_t</span> header_version;<br>    <span class="hljs-type">uint32_t</span> os_version;<br>    ...<br>    <span class="hljs-type">uint32_t</span> recovery_[dtbo|acpio]_size;    <span class="hljs-comment">/* size of recovery image */</span><br>    <span class="hljs-type">uint64_t</span> recovery_[dtbo|acpio]_offset;  <span class="hljs-comment">/* offset in boot image */</span><br>    <span class="hljs-type">uint32_t</span> header_size;               <span class="hljs-comment">/* size of boot image header in bytes */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>  这时候设备就可以添加用于 recovery 的 dtbo | acpio 的内容了</p>
<p>  在 Android 10 ， bootheader 更新到了 v2，添加了 dtb 相关信息的字段</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br>    <span class="hljs-type">uint32_t</span> header_size;               <span class="hljs-comment">/* size of boot image header in bytes */</span><br>    <span class="hljs-type">uint32_t</span> dtb_size;                  <span class="hljs-comment">/* size of dtb image */</span><br>    <span class="hljs-type">uint64_t</span> dtb_addr;                  <span class="hljs-comment">/* physical load address */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>  可以看到，这个时候 dtb 从内核上分离了出来，有了单独的存储区域，这也是为什么不再使用在内核后连接 dtb 的编译形式，<code>CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE</code> 也就不会被打开了</p>
<p>  而 Android 11 ，bootheader 更新至 v3，改动较大</p>
<ol>
<li>移除了第二阶段引导加载程序的相关信息</li>
<li>移除了 recovery 分区的相关信息</li>
<li>移除了 dtb 的相关信息</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOT_MAGIC_SIZE 8</span><br>    <span class="hljs-type">uint8_t</span> magic[BOOT_MAGIC_SIZE];<br><br>    <span class="hljs-type">uint32_t</span> kernel_size;    <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-type">uint32_t</span> ramdisk_size;   <span class="hljs-comment">/* size in bytes */</span><br><br>    <span class="hljs-type">uint32_t</span> os_version;<br><br>    <span class="hljs-type">uint32_t</span> header_size;    <span class="hljs-comment">/* size of boot image header in bytes */</span><br>    <span class="hljs-type">uint32_t</span> reserved[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">uint32_t</span> header_version; <span class="hljs-comment">/* offset remains constant for version check */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOT_ARGS_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOT_EXTRA_ARGS_SIZE 1024</span><br>    <span class="hljs-type">uint8_t</span> cmdline[BOOT_ARGS_SIZE + BOOT_EXTRA_ARGS_SIZE];<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>  这个时候，AB 设备中的 recovery 分区被合并进了 boot 分区，也就没有必要再指定 recovery 所使用的 dtbo | acpio，原本属于 bootheader 中的内容的 dtb 被放置到了 vendor_boot 分区中，所以也没有必要再放置有关 dtb 的信息</p>
<p>  至于 vendor_boot ，是在 Android 11 中为兼容 GKI 而引入的新分区，所有 OEM 的修改都被分离到 vendor_boot 中，剩余部分使用 AOSP 通用内核的编译产物</p>
<p>  而 A only 设备则只能止步于此，因为使用单独的 recovery 分区和 boot 分区，所以它们只能使用到 bootheader v2</p>
<p>  到 Android 12 ， bootheader 更新至了 v4</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOT_MAGIC_SIZE 8</span><br>    <span class="hljs-type">uint8_t</span> magic[BOOT_MAGIC_SIZE];<br><br>    <span class="hljs-type">uint32_t</span> kernel_size;    <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-type">uint32_t</span> ramdisk_size;   <span class="hljs-comment">/* size in bytes */</span><br><br>    <span class="hljs-type">uint32_t</span> os_version;<br><br>    <span class="hljs-type">uint32_t</span> header_size;    <span class="hljs-comment">/* size of boot image header in bytes */</span><br>    <span class="hljs-type">uint32_t</span> reserved[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">uint32_t</span> header_version; <span class="hljs-comment">/* offset remains constant for version check */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOT_ARGS_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOT_EXTRA_ARGS_SIZE 1024</span><br>    <span class="hljs-type">uint8_t</span> cmdline[BOOT_ARGS_SIZE + BOOT_EXTRA_ARGS_SIZE];<br><br>    <span class="hljs-type">uint32_t</span> signature_size; <span class="hljs-comment">/* size in bytes */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>  新增了一个 <code>uint32_t</code> 类型的 <code>boot_signature</code> 字段，用于验证内核和 ramdisk 的完整性，但须注意的是，该字段并不参与 AVB 的启动过程而只由 VTS 测试使用</p>
<p>  bootheader v4 同时还支持了分段的 vendor_boot 分区</p>
<p>  关于 bootheader 的讨论到此结束，剩余部分请查阅 AOSP 项目文档</p>
<p>  同理，上面中的 <code>BOARD_KERNEL_BASE</code> 和 <code>BOARD_KERNEL_PAGESIZE</code> 也可以从 <code>unpackbootimg</code> 中的输出信息中得到</p>
<p>  事实上，像凛凛佬直播中使用的 <code>magiskboot</code> 程序会有更加良好的格式化以及更佳的可读性，同样也推荐使用</p>
<p>  对于 <code>BOARD_KERNEL_SEPARATED_DTBO</code>，这个 flag 在有独立的 dtbo 分区的设备上是必须打开的，它控制编译系统是否支持以及编译单独的 dtbo 分区</p>
<p>  而 <code>BOARD_MKBOOTIMG_ARGS</code> 则是在生成 <code>boot.img</code> 时，传递给 <code>mkbootimg</code> 程序的参数，比如上述参数</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">BOARD_MKBOOTIMG_ARGS += --header_version <span class="hljs-variable">$(BOARD_BOOTIMG_HEADER_VERSION)</span><br></code></pre></td></tr></table></figure>
<p>  意思就是给 <code>mkbootimg</code> 传入一个 –header_version 的参数，后面的是你的 bootheader version，已经在之前定义过了</p>
<p>  下面的 <code>TARGET_KERNEL_ADDITIONAL_FLAGS</code> 则是在编译内核 <code>Image</code> 的时候，要传递给 <code>make</code> 程序的额外参数，比如上文中给出的</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">TARGET_KERNEL_ADDITIONAL_FLAGS := DTC_EXT=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>/prebuilts/misc/<span class="hljs-variable">$(HOST_OS)</span>-x86/dtc/dtc<br></code></pre></td></tr></table></figure>
<p>  其中 <code>pwd</code> 指令是自己当前所在的目录，这样展开其实就是 <code>$ANDROID_ROOT/prebuilts/misc/linux-x86/dtc/dtc</code> 传入这一句的意思是向 <code>make</code> 程序说明，我们不希望使用内核源码中自带的 dtc ( device tree compiler | 内核设备树编译器 ) 编译内核的 dts，而是使用这个外部的预编译的 dtc ，这样做一方面是可以避免因为 dtc 版本不同而导致语法的不兼容，避免编译失败，也可以节约使用 HOSTCC 编译 dtc 的时间 ( 虽然说这个时间成本跟编译整个系统比起来要低很多就是了… )</p>
<p>  有的时候我们还需要用这个 flag 来传递一些信息，比如我们可以传入</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">TARGET_KERNEL_ADDITIONAL_FLAGS += OBJDUMP=llvm-objdump<br></code></pre></td></tr></table></figure>
<p>  这一句的意思是我们想要使用 LLVM 的 <code>objdump</code> 程序而不是用 <code>gcc</code> 的</p>
<p>  而最后面的三个 flag 就比较易懂了，它们的作用已经写在了它们的名字里</p>
<p>  内核部分结束了，然后是分区的定义</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Metadata</span><br>BOARD_USES_METADATA_PARTITION := true<br></code></pre></td></tr></table></figure>
<p>  这个 flag 指定了你需不需要用 <code>metadata</code> 分区进行加密，现在采用 FBEv1&#x2F;v2 的机器基本上都会使用这个分区，同样地 <code>fastboot</code> 程序返回的数据里也会有关于这个分区的信息，视情况打开它就好</p>
<p>  下面的是 oss vendor 所使用的分区信息<br>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Partitions</span><br>BOARD_BOOTIMAGE_PARTITION_SIZE := 134217728<br>BOARD_CACHEIMAGE_PARTITION_SIZE := 402653184<br>BOARD_DTBOIMG_PARTITION_SIZE := 33554432<br>BOARD_RECOVERYIMAGE_PARTITION_SIZE := 134217728<br>BOARD_USERDATAIMAGE_PARTITION_SIZE := 114919714816<br><br>BOARD_SUPER_PARTITION_SIZE := 9126805504<br>BOARD_SUPER_PARTITION_GROUPS := qti_dynamic_partitions<br>BOARD_QTI_DYNAMIC_PARTITIONS_PARTITION_LIST := system system_ext product odm vendor<br>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE := 9122611200<br><br>BOARD_FLASH_BLOCK_SIZE := 262144<br><br>BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE := ext4<br>BOARD_ODMIMAGE_FILE_SYSTEM_TYPE := erofs<br>BOARD_PRODUCTIMAGE_FILE_SYSTEM_TYPE := erofs<br>BOARD_SYSTEM_EXTIMAGE_FILE_SYSTEM_TYPE := erofs<br>BOARD_SYSTEMIMAGE_FILE_SYSTEM_TYPE := erofs<br>BOARD_VENDORIMAGE_FILE_SYSTEM_TYPE := erofs<br><br>BOARD_EROFS_PCLUSTER_SIZE := 65536<br>BOARD_EROFS_USE_ZTAILPACKING := true<br><br>TARGET_COPY_OUT_ODM := odm<br>TARGET_COPY_OUT_PRODUCT := product<br>TARGET_COPY_OUT_SYSTEM_EXT := system_ext<br>TARGET_COPY_OUT_VENDOR := vendor<br></code></pre></td></tr></table></figure><br>  首先是第一组数据，定义了 <code>boot, cache, dtbo, recovery, userdata</code> 这几个分区的大小，这些属性同样也都会在你执行 <code>fastboot getvar all</code> 的时候悉数返回给你，只不过返回的值是 16 进制的，你需要用一些工具把它转换成 10 进制</p>
<p>  第二组中，<code>BOARD_SUPER_PARTITION_SIZE</code> 定义了你的 super 分区的大小，获取方式同上，需要注意的是，只有在使用动态分区的设备上，第二块内容的定义才是必要的，否则如果没有使用动态分区，那么不需要定义 <code>DYNAMIC_PARTITIONS</code> 的相关属性</p>
<p>  特别地，如果你的设备使用了 bootheader v3&#x2F;v4 并且拥有 <code>vendor_boot</code> 分区，那么你还需要定义 <code>BOARD_VENDOR_BOOT_PARTITIONS_SIZE</code> 这个 flag 来告诉编译系统 <code>vendor_boot</code> 分区的大小</p>
<p>  其中还有一个 flag ，<code>BOARD_QTI_DYNAMIC_PARTITIONS_PARTITION_LIST</code> 定义了你的 super 分区中有哪些子分区，比如对于我们的 oss vendor 的编译需求，我们会需要去尽可能多的减少底包对我们的稳定性，所以我们需要将 super 分区里的全部内容都修改成我们需要的，也就是说我们编译我们需要的分区并且放进去，比如我们下面最后一组数据定义了我们会自行编译哪些分区的镜像，可以看到，有 <code> vendor product system_ext odm</code> 当然还有最重要的 <code>system</code> ，所以我们把它们写入动态分区的列表中，告诉编译系统，生成 super 分区镜像的时候需要把哪些子分区的镜像一起打包进去</p>
<p>  而对于 prebuit vendor ，不需要编译那么多东西，通常只需要 <code>system product system_ext</code> 就可以了</p>
<p>  至于名字为什么是 <code>QTI_DYNAMIC_PARTITIONS</code> ，这都不要紧，可以自己定义一个，比如上面 <code>BOARD_SUPER_PARTITION_GROUPS</code> flag 定义的是 <code>qti_dynamic_partitions</code> ，我可以改成 <code>picasso_dynamic_partitions</code>，只不过把所有的 <code>QTI_DYNAMIC_PARTITIONS</code> 都换成 <code>PICASSO_DYNAMIC_PARTITIONS</code> 就可以了</p>
<p>  而对于 <code>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE</code> 的计算方法</p>
<ul>
<li>Virtual AB:  <code>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE</code> &#x3D; <code>BOARD_SUPER_PARTITION_SIZE</code> - <code>overhead</code></li>
<li>AB: <code>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE</code> &#x3D; <code>BOARD_SUPER_PARTITION_SIZE</code> &#x2F; 2  - <code>overhead</code></li>
<li>non-AB: <code>BOARD_QTI_DYNAMIC_PARTITIONS_SIZE</code> &#x3D; <code>BOARD_SUPER_PARTITION_SIZE</code> - <code>overhead</code></li>
</ul>
<p>  其中 overhead 通常等于 4MB ，注意减去该值时需要将 MB 转化为 byte 才可以相减</p>
<p>  下面的 <code>BOARD_FLASH_BLOCK_SIZE</code> 会定义在你的 boot.img 里，使用 <code>unpackbootimg</code> 工具可以看到这个值，它用于告诉 <code>fastboot</code> 它最大能一次刷入多少大小的东西，如果分区镜像文件的总大小超过了这个值，那就需要分步刷入，比如分成 7 次，每次刷入一点，这个值可以比 boot.img 中提取得到的值小，但绝对不能大，如果设置过大的话会导致无法刷入</p>
<p>  第四组 flags 则是定义了你需要用什么样的分区格式，与 fstab 中的保持一致就好，需要注意的是，使用 <code>erofs</code> 文件系统需要内核支持，如若不支持请不要用 <code>erofs</code></p>
<p>  最后一组就是定义了这些分区最终的编译产物的输出目录，copy 就好</p>
<p>  然后是一些杂项</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Platform</span><br>BOARD_USE_QCOM_HARDWARE := true<br>TARGET_BOARD_PLATFORM := lito<br></code></pre></td></tr></table></figure>
<p>  前一个比较明显，高通设备打开就好了，后面的那个跟你的 <code>TARGET_BOOTLOADER_BOARD_NAME</code> 保持一致就好了</p>
<p>  然后是 Recovery 相关的配置</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">&gt;&gt;&gt;&gt;&gt;&gt;&gt; picasso: Recovery Section<br><span class="hljs-comment"># Recovery</span><br>BOARD_INCLUDE_DTB_IN_BOOTIMG := true<br>BOARD_INCLUDE_RECOVERY_DTBO := true<br>TARGET_RECOVERY_FSTAB := <span class="hljs-variable">$(DEVICE_PATH)</span>/rootdir/etc/fstab.qcom<br>TARGET_RECOVERY_PIXEL_FORMAT := <span class="hljs-string">&quot;BGRA_8888&quot;</span><br>TARGET_USERIMAGES_USE_EXT4 := true<br>TARGET_USERIMAGES_USE_F2FS := true<br>========<br><span class="hljs-comment"># Recovery</span><br>BOARD_INCLUDE_RECOVERY_DTBO := true<br>BOARD_USES_RECOVERY_AS_BOOT := true<br>TARGET_NO_RECOVERY := true<br>TARGET_RECOVERY_FSTAB := <span class="hljs-variable">$(DEVICE_PATH)</span>/recovery/recovery.fstab<br>TARGET_RECOVERY_PIXEL_FORMAT := <span class="hljs-string">&quot;RGBX_8888&quot;</span><br>TARGET_USERIMAGES_USE_EXT4 := true<br>TARGET_USERIMAGES_USE_F2FS := true<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; thyme: Recovery Section<br></code></pre></td></tr></table></figure>

<p>  可以看到差别不是很大，而且 flag 的名字也比较易懂，就只介绍 non-AB 和 AB 有什么异同点</p>
<p>  对于 bootheader v2 及以上的具有独立 dtbo 分区的设备而言，<code>BOARD_INCLUDE_RECOVERY_DTBO</code> 需要打开，这一点 <code>picasso</code> 是 v2，<code>thyme</code> 是 v3，所以它们都启用了这个 flag，<code>BOARD_INCLUDE_DTB_IN_BOOTIMG</code> 在 <code>picasso</code> 的配置中打开了，但是 <code>thyme</code> 没有打开，原因可以参照前文的 bootheader v3 发生的变化，它的 dtb 不再包含在 boot 分区中，而是移动到了 <code>vendor_boot</code> 分区里，所以 <code>boot.img</code> 里是不含 dtb 的，然后就是 <code>BOARD_USES_RECOVERY_AS_BOOT</code> 和 <code>TARGET_NO_RECOVERY</code> ，同样地，这个时候 AB 分区的手机不再有独立的 recovery 分区，而是合并进了 boot 分区，所以 <code>thyme</code> 打开了这两个 flag 而 <code>picasso</code> 没有</p>
<p>  下面介绍它们共有的 flags</p>
<p>  首先是 <code>TARGET_RECOVERY_FSTAB</code> ，它指定了你的 recovery 在挂载分区的时候应该使用哪个 fstab ，可以看到这里 <code>picasso</code> 直接复用了编译进系统的 fstab ，而 <code>thyme</code> 则是单独摘了一个出来，都可以</p>
<p>  然后是 <code>TARGET_RECOVERY_PIXEL_FORMAT</code>，它描述了你的 recovery 使用什么样的像素格式，像凛凛视频里那样介绍的拿取这个 flag 的值就好，或者也可以直接 copy 别的，影响不大</p>
<p>  然后两个 flags 指定了你的 userdata 分区的格式，顾名思义即可</p>
<p>  Android Verified Boot 的话… 直接去看 AOSP 的文档就好了，看看每一项都有什么作用</p>
<p>  比较奇怪的一点是，在我翻源码的时候并没有找到传递给 <code>avbtool make_vbmeta_image</code> 的 <code>--flags</code> 标志位是什么含义，如果有人知道为什么要加上这个 <code>--flags 3</code> 的话请告诉我，十分感谢</p>
<p>  BoardConfig.mk 的内容肯定不止有这一点点，之后我们还会再加入，以完善这个设备树</p>
</li>
<li><p>device.mk</p>
<p>  这个文件里主要定义了你需要编译进系统里的各种软件包，库文件，配置文件等等，你的大部分精力基本上都是花在这些东西上的，下面来分解一下 prebuilt vendor 的内容</p>
<p>  首先是 include 外部的 Makefile ，它们一般是这个格式</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Installs gsi keys into ramdisk, to boot a GSI with verified boot.</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> inherit-product, <span class="hljs-variable">$(SRC_TARGET_DIR)</span>/product/developer_gsi_keys.mk)</span><br></code></pre></td></tr></table></figure>
<p>  需要注意的是凛凛直播中说到的 Updatable APEX ( 不是 APEX Legend !!! ) 我们使用 oss vendor 一般都不会打开，因为 ROM 优化的 jemalloc 或者 mimalloc 都在这里面， update 了之后就没了，而且在一些设备上还会造成 <code>bootloop</code>，所以这里不多提了，不过它是很好的虚拟化和容器化的例子，感兴趣的话可以学习一下</p>
<p>  当然说 prebuilt 必须要加上这个，毕竟它 vendor 自带的 apex 多半是我们不能用的，所以要 update 成我们自己的</p>
<p>  下面是 thyme 等 VAB 机型必须加入的内容</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Virtual A/B</span><br>ENABLE_VIRTUAL_AB := ture<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> inherit-product, <span class="hljs-variable">$(SRC_TARGET_DIR)</span>/product/virtual_ab_ota.mk)</span><br></code></pre></td></tr></table></figure>
<p>  意思比较一目了然，表明你的设备支持并使用了 Virtual A&#x2F;B 分区布局，如果不是 VAB 的话这里不需要加</p>
<p>  然后是 Dalvik VM 堆内存的配置</p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># Setup dalvik vm configs<br><span class="hljs-constructor">$(<span class="hljs-params">call</span> <span class="hljs-params">inherit</span>-<span class="hljs-params">product</span>, <span class="hljs-params">frameworks</span><span class="hljs-operator">/</span><span class="hljs-params">native</span><span class="hljs-operator">/</span><span class="hljs-params">build</span><span class="hljs-operator">/</span><span class="hljs-params">phone</span>-<span class="hljs-params">xhdpi</span>-6144-<span class="hljs-params">dalvik</span>-<span class="hljs-params">heap</span>.<span class="hljs-params">mk</span>)</span><br><br></code></pre></td></tr></table></figure>

<p>  现代手机基本都是 6GB+ 了，所以直接用这个就好，然后的话对于老机型就去这个目录下找你对应的内存容量，加上就好了</p>
<p>  然后是这个标记设备出厂时的 Android 版本的 flag</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Shipping API level</span><br>PRODUCT_SHIPPING_API_LEVEL := 29<br></code></pre></td></tr></table></figure>

<p>  是几就写几，特别重要不能写错，Android 版本与 API 版本的对应关系可以在 AOSP 文档里查到</p>
<p>  然后就是 AB 系统更新的内容</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># A/B</span><br>AB_OTA_POSTINSTALL_CONFIG += \<br>    RUN_POSTINSTALL_system=true \<br>    POSTINSTALL_PATH_system=system/bin/otapreopt_script \<br>    FILESYSTEM_TYPE_system=ext4 \<br>    POSTINSTALL_OPITIONAL_system=true<br><br></code></pre></td></tr></table></figure>

<p>  直接 copy 就好啦，不过要注意的是有的厂商会使用 erofs 或者别的文件系统 ，<code>FILESYSTEM_TYPE_system</code>要跟着一起变（ 最好 ) ，总之跟 fstab 中保持一致即可</p>
<p>  然后设定启动动画的分辨率</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Boot animation</span><br>TARGET_SCREEN_HEIGHT := 2400<br>TARGET_SCREEN_WIDTH := 1080<br></code></pre></td></tr></table></figure>

<p>  这就看你设备具体长宽是多少了，单位是像素</p>
<p>  下面定义了你的 init 脚本配置</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Common init scripts</span><br>PRODUCT_PACKAGES += \<br>    init.recovery.qcom.rc<br></code></pre></td></tr></table></figure>

<p>  见凛凛 commit 里的内容，这是我们目前为止遇到的第一个 product package，也就是编译进你的设备的 “包” ，顺带提一嘴如何用 Android.mk 定义一个简单的模块，也就是所谓的 “包”</p>
<blockquote>
<p> File: $DEVICE_PATH&#x2F;rootdir&#x2F;Android.mk</p>
</blockquote>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">include</span> <span class="hljs-variable">$(CLEAR_VARS)</span><br>LOCAL_MODULE       := init.recovery.qcom.rc<br>LOCAL_MODULE_TAGS  := optional<br>LOCAL_MODULE_CLASS := ETC<br>LOCAL_SRC_FILES    := etc/init.recovery.qcom.rc<br>LOCAL_MODULE_PATH  := <span class="hljs-variable">$(TARGET_ROOT_OUT)</span><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(BUILD_PREBUILT)</span><br></code></pre></td></tr></table></figure>

<p>  上面的字段中，首先是 include 了 <code>$(CLEAR_VARS)</code>，用于清除之前一个模块的配置信息 ( 比如前一个模块定义的 <code>LOCAL_MODULE</code> )，以免影响到我们这个模块的编译，然后是 <code>LOCAL_MODULE_CLASS</code> 定义了你这个模块所属的类，比如这个模块属于 ETC 类，后面的 <code>LOCAL_SRC_FILES</code> 则是定义了这个文件的具体位置 (相对于 Android.mk 的路径)，后面的 <code>LOCAL_MODULE_PATH</code> 定义了最后你的这个文件会被拷贝到哪里去，比如上文的这个模块，<code>init.recovery.qcom.rc</code> 就会被放置到 <code>$(TARGET_ROOT_OUT)</code> 这个位置，它是 AOSP 编译系统预先定义好的一组环境变量，用来告知编译系统你想把这个文件放到哪里，这里的意思就是放在 <code>root</code> 目录，其实对于 system-as-root 而言，也就是放进 system 里，以前的不使用 system-as-root 的机型可能会有 ramdisk，或者使用 2 Stage init 的设备也会有一个 ramdisk，最后就是 <code>include $(BUILD_PREBUILT)</code> ，它指明了你定义的这是个什么类型的文件，比如这个就是一个 prebuilt 文件，它决定了编译系统最后会怎么处置这个模块定义的源文件，它们也是 AOSP 编译系统预先定义的一组环境变量，可以去 build&#x2F;make 里查看</p>
<p>  好的继续</p>
<p>  上面 Common init scripts 字段中， <code>PRODUCT_PACKAGES</code> 定义了你需要将哪些包编译进系统，需要注意的是，这时候为这个变量赋值的时候必须使用 <code>+=</code> 运算符而不能使用 <code>:=</code>，使用后者会导致你原本的 <code>PRODUCT_PACKAGES</code> 被 override，这样很多软件包就丢了，毕竟这么大一个系统，不能只编译咱们定义的这几个 packages，所以上面那一句赋值的意思就是你想要多编译一个叫 <code>init.recovery.qcom.rc</code> 的包进入系统，加上这一句之后编译系统就会在它能访问的命名空间里找这个模块并且帮你编译进去，如果它找不到，它就会向你报错，告诉你这个模块它找不到，请君明鉴</p>
<p>  然后是 fastbootd 的内容，fastbootd 是用户空间内的 fastboot 程序，用于操作 super 分区内的子分区，比如 system, vendor, system_ext 等等</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Fastbootd</span><br>PRODUCT_PACKAGES += \<br>    fastbootd \<br>    android.hardware.fastboot@1.0-impl-mock<br></code></pre></td></tr></table></figure>

<p>  之后的内容就比较简单了，只记录下 initial commit 的内容</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># F2FS utilities</span><br>PRODUCT_PACKAGES += \<br>    sg_write_buffer \<br>    f2fs_io \<br>    check_f2fs \<br><br><span class="hljs-comment"># Partitions</span><br>PRODUCT_BUILD_SUPER_PARTITION := false<br>PRODUCT_USE_DYNAMIC_PARTITIONS := true<br><br><span class="hljs-comment"># Soong namespace</span><br>PRODUCT_SOONG_NAMESPACE := \<br>    <span class="hljs-variable">$(LOCAL_PATH)</span><br><br><span class="hljs-comment"># Update engine</span><br>PRODUCT_PACKAGES += \<br>    otapreopt_script \<br>    update_engine \<br>    update_engine_sideload \<br>    update_verifier<br><br>PRODUCT_PACKAGES_DEBUG += \<br>    update_engine_client<br><br>PRODUCT_HOST_PACKAGES += \<br>    brillo_update_payload<br></code></pre></td></tr></table></figure>

<p>  需要注意的是 Update engine 只有 A&#x2F;B 设备才会使用，Aonly 的设备不需要添加这些</p>
<p>  然后是为 ramdisk 添加 fstab.qcom</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Vendor Boot</span><br>PRODUCT_COPY_FILES += \<br>    <span class="hljs-variable">$(LOCAL_PATH)</span>/rootdir/etc/fstab.qcom:<span class="hljs-variable">$(TARGET_COPY_OUT_VENDOR_RAMDISK)</span>/first_stage_ramdisk/fstab.qcom<br></code></pre></td></tr></table></figure>

<p>  其中有些分区需要在第一阶段 init 的时候挂载，不然的话后续的系统加载流程找不到这些分区，系统就无法启动，对于 bootheader v3&#x2F;v4 使用 Virtual A&#x2F;B 分区布局的设备来说，我们需要把它拷贝到 <code>vendor_boot</code> 里的第一阶段 init 读取的目录，对于 A&#x2F;B 或者 non-A&#x2F;B 设备，我们只需要把它拷贝到第一阶段 ramdisk 里就好，比如你可以定义一下下面的模块</p>
<blockquote>
<p>$(DEVICE_PATH)&#x2F;rootdir&#x2F;Android.mk</p>
</blockquote>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> <span class="hljs-variable">$(CLEAR_VARS)</span><br>LOCAL_MODULE       := fstab.qcom.ramdisk<br>LOCAL_MODULE_STEM  := fstab.qcom<br>LOCAL_MODULE_TAGS  := optional<br>LOCAL_MODULE_CLASS := ETC<br>LOCAL_SRC_FILES    := etc/fstab.qcom<br>LOCAL_MODULE_PATH  := <span class="hljs-variable">$(TARGET_RAMDISK_OUT)</span><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(BUILD_PREBUILT)</span><br></code></pre></td></tr></table></figure>

<p>  然后在 device.mk 里选择编译它</p>
<blockquote>
<p>$(DEVICE_PATH)&#x2F;device.mk</p>
</blockquote>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Fstab</span><br>PRODUCT_PACKAGES += \<br>    fstab.qcom.ramdisk<br></code></pre></td></tr></table></figure>

<p>  后面凛凛直播的内容就是找文件了 (主要是 fstab) 和一个 init rc</p>
<p>  基本的目录结构到这里就介绍完了</p>
</li>
</ul>
<h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><p>其实凛凛在直播里说的很正确，前人已经踩过的坑就没有必要自己去踩一遍了，对于 bring up 新设备而言也是如此，找一个硬件跟你的手机差异不大的已经有 device tree 的机型做参考无疑是最佳的选择，这样可以少走很多弯路，使用它们的 commits ，然后自己去试着编译，哪里出问题了修哪里，修到最后，你的 device tree 也就大成了，在这个修的过程中你也会收获很多知识，得到很多经验，干这一块知识储备固然重要，但是经验也是很重要的，很多问题大佬看一眼就明白是哪里出了问题，是因为这个问题他遇到过了，他知道怎么去修复，或者他的知识储备很丰富，推断出这个问题可以怎么解决，对于高通设备而言，Soc 型号不一样甚至都没什么大问题，用同一个 tag ，需要的流程就基本一致，拿 lito 和 kona 举例子吧，它们都使用 SMxx50 的 tag，甚至 lito 的设备 inherit kona 的 common tree 做一点点然后编译就能开机</p>
<h2 id="私有-blobs"><a href="#私有-blobs" class="headerlink" title="私有 blobs"></a>私有 blobs</h2><p>也就是凛凛直播中提到的第二个 commit</p>
<blockquote>
<p><code>3a51ade thyme: Import extract utils</code></p>
</blockquote>
<p>这个 commit 里提交了三个文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">extract-files.sh<br>setup-makefiles.sh<br><br>proprietary-files.txt<br></code></pre></td></tr></table></figure>
<p>这三个文件非常重要，它们协同工作，从厂商的 rom 里提取 blobs，生成了你的 vendor tree ，今后如果使用 oss vendor ，这三个文件更是重中之重</p>
<p>上面的 <code>extract-files.sh</code> 会读取 <code>proprietary-files.txt</code> 中的文件，然后从你厂商的 rom dump 里一个一个的把它们揪出来，放进 <code>vendor/&lt;manufacturer&gt;/&lt;devicecodename&gt;</code> ，为什么要从厂商的 dump 里提取呢，因为它们是私有的二进制文件，不能从 AOSP&#x2F;CLO 源码里编译出来，所以我们必须使用它们来让一些 (实际上是几乎全部的) 硬件跑起来</p>
<p>对于 prebuilt vendor， <code>proprietary-files.txt</code> 里的内容比较好搞，就直接 copy 那些内容，至于 oss vendor，放在之后补充</p>
<p>凛凛的直播里说的很对的，不再赘述</p>
<h2 id="vbmeta-与-dtbo"><a href="#vbmeta-与-dtbo" class="headerlink" title="vbmeta 与 dtbo"></a>vbmeta 与 dtbo</h2><p>接着就是下面一条 commit 的内容</p>
<blockquote>
<p>61c5e31 thyme: releasetools: Ship and update vbmeta and dtbo images<br>76bfff7 thyme: releasetools: Add vbmeta_system to output zip</p>
</blockquote>
<p>所谓 releasetools ，顾名思义，就是用来往你最终的那个 zip 里添加文件的一个 python 脚本，AOSP 编译系统默认不会把 dtbo 和 vbmeta 分区镜像添加进我们最终的 zip，所以我们需要自定义一下它来让它识别我们编译得到的这些镜像并把它们加入</p>
<p>同样地，如果想要在编译 rom 的时候顺便把 firmware 更新一并做进去的话，靠的也是这个文件</p>
<h2 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h2><p>接下来你要面对的是整个过程里最让你头疼没有之一的东西，SELinux</p>
<p>Security-Enhanced Linux ，是 Linux MAC 权限控制框架下的一个基于标签的强制权限控制实现，由美国国家安全局 (NSA) 开发并开源，目的是为了增强 Linux 的安全性，限制程序对系统的修改，该组件自 Linux 2.6 被合并入 Linux 主线并于 Android 4.4 开始为 Android 提供全面保护</p>
<p>上面说的那么好，为什么令人头疼呢，那就是因为它的权限控制策略配置，真的超级超级麻烦…</p>
<blockquote>
<p>2048f0e thyme: include QCOM Sepolicy</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Sepolicy</span><br><span class="hljs-keyword">include</span> device/qcom/sepolicy/SEPolicy.mk<br></code></pre></td></tr></table></figure>

<p>Android 编译系统依赖 SELinux 上下文来确定每个文件的权限标签，不 include 它的话甚至编译都过不去，然后就是将 SELinux 设置为宽容模式</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">BOARD_KERNEL_CMDLINE += androidboot.selinux=permissive<br></code></pre></td></tr></table></figure>
<p>SELinux 会阻止所有未经策略配置允许的对系统资源的访问，如果让 SELinux 处于强制模式而你还没有配置好它的策略的话，它会阻止 Android 系统的正常启动，你是绝对开不了机的</p>
<p>开机之后就需要配置 sepolicy，以便于日后的 enforcing，所有未经允许的访问 SELinux 都会通过 <code>logcat</code> 或者 <code>dmesg</code> 日志来告诉你，它的格式一般是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">09-23 20:44:39.878 19355:19355 W android.hardware.fingerprint@2.1-service_picasso: type=1400 audit(0.0:410972): avc: denied &#123; create &#125; for name=&quot;gf_data&quot; scontext=u:r:hal_fingerprint_default:s0 tcontext=u:object_r:system_data_root_file:s0 tclass=dir permissive=1<br></code></pre></td></tr></table></figure>
<p>其中的 <code>&#123;&#125;</code> 里面的内容告诉了你是哪个操作被阻止了， <code>name</code> 的内容告诉你是什么东西发起了这个操作，<code>scontext</code> 的内容告诉你发起这个操作的程序的 selinux 上下文标签是什么，比如上面的例子里它的标签就叫 <code>hal_fingerprint_default</code>，然后 <code>tcontext</code> 的内容告诉你，被访问的目标的 selinux 上下文标签是什么，比如上面的例子里它是 <code>system_data_root_file</code>，后面的 <code>tclass</code> 标识了被访问的内容是什么东西，在这个例子里它是 <code>dir</code> ，也就是个目录，后面的 <code>permissive</code>标识当前 selinux 运行在什么模式下，比如这个例子里它运行在宽容模式下，那么 <code>permissive</code> 就是 1，如果它运行在 enforcing ( 强制 ) 模式下，那么它的值会变成 0</p>
<p>你会得到一大堆像这种形式一样的报错，你的任务就是一个一个的去把它们解决掉然后添加策略… 是不是有点太麻烦了？？？</p>
<p>不错，NSA 为我们提供了修复它的工具，<code>audit2allow</code>，详情可以直接查看 AOSP 文档，它会手把手的教你怎么用这个工具</p>
<h2 id="VINTF"><a href="#VINTF" class="headerlink" title="VINTF"></a>VINTF</h2><p>Vendor 接口对象，描述了你的设备中所有 HAL 的信息，以供编译时对 HAL 接口的检查以及运行时 <code>getTransport</code> 来找到各个 HAL 的接口入口 ( 当然如果它找不到的话就会报错你就开不了机XD )，同时它也是 CTS 测试的重要一部分</p>
<p>对了.. 凛凛直播的时候可能是太紧张口误说错了一个地方，就是 HAL 它是硬件抽象层 ( Hardware Abstraction Layer ) 而不是硬件叠加层 ( Hardware Overlay Layer )，这两个概念是不同的，感兴趣的同学可以自己去查一查维基</p>
<blockquote>
<p><code>2055f62 thyme: Import FCM from stock</code></p>
</blockquote>
<p>整个 VINTF 体现在你 oss device tree 里其实有三个文件</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">manifests.<span class="hljs-keyword">xml</span><br><span class="hljs-title">compatibility_matrixes</span>.<span class="hljs-keyword">xml</span><br><span class="hljs-title">framework_compatibility_matrixes</span>.xml<br></code></pre></td></tr></table></figure>

<p>oss tree 稍后会再讲，嘛… 对于 prebuilt vendor 来说没那么麻烦，你就只需要一个 <code>framework_compatibility_matrixes.xml</code> 就足够了，这个文件是跟你 framework 里定义的 HAL 相关的，而对于你 device 自定义的 HAL 才需要上面的两个文件来描述它们，而这些 prebuilt vendor 都已经包含了，所以不需要</p>
<p>从扩展名就可以看出， VINTF 配置文件采用 xml 语法，一般对于 <code>manifest.xml</code> 中的项来说，它们一般都像这样</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>android.hardware.biometrics.fingerprint<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IBiometricsFingerprint<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>name</code> 定义了一个 HAL 的名字</li>
<li><code>transport</code> 定义了该 HAL 使用什么方式进行通信，对于 Android 9 之后 binderlized 的 HAL 而言一般都是 <code>hwbinder</code>，对于一些老的 HAL 它们通常是 <code>passthrough</code></li>
<li><code>version</code> 标记了这个 HAL 的版本</li>
<li><code>interface</code> 定义了这个 HAL 的接口，也就是 <code>getTransport</code> 需要的东西，这个接口可以有多个，比如下面 <code>vendor fingerprint hal</code> 的例子</li>
<li><code>interface</code> -&gt; <code>name</code> 标记了一个接口的名称</li>
<li><code>interface</code> -&gt; <code>instance</code> 标记了这个接口的实现，实现可以有多个</li>
</ul>
<p>这里<code>name</code> 和 <code>instance</code> 可以唯一确定一个接口，它们绝不会有重复</p>
<p>这是一个 <code>Vendor Fingerprint HAL</code> 的例子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>vendor.goodix.hardware.cap.biometrics.fingerprint<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IGoodixFingerprintDaemon<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IGoodixFingerprintDaemonExt<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可以看到 <code>interface</code>可以有多个，它也可以这么写</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>vendor.goodix.hardware.cap.biometrics.fingerprint<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@2.1::IGoodixFingerprintDaemon/default<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@2.1::IGoodixFingerprintDaemonExt/default<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>用 <code>fqname</code> 可以简化写法，甚至可以定义不同接口多个版本，像下面 <code>Radio HAL</code> 的写法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>android.hardware.radio<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@1.5::IRadio/slot1<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@1.5::IRadio/slot2<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@1.2::ISap/slot1<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@1.2::ISap/slot2<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当然说具体应该写什么还得看系统给你报什么错，这个错误一般是由 <code>check_vintf_list</code> 在编译时报错以及 <code>hwservicemanager</code> 的  <code>getTransport</code> 在运行时报错，错一个修一个就可以</p>
<p>不过一般也不用你来写，可以从 CLO 直接拿或者从 dump 里提取，用 find + grep 找它就好了</p>
<h2 id="BootControl-HAL"><a href="#BootControl-HAL" class="headerlink" title="BootControl HAL"></a>BootControl HAL</h2><blockquote>
<p><code>77e9181 thyme: Import and Build bootctl from CAF</code></p>
</blockquote>
<p>Boot Control HAL 是使用 A&#x2F;B 无缝系统更新的设备必须实现的 HAL ，它会接收来自系统 <code>update_engine</code> 的消息，选择启动时应该使用哪一个槽位，它实现了启动过程中的一个状态机，根据不同的情况进行不同的槽位选择</p>
<p>使用 A&#x2F;B 无缝系统更新的设备 OEM 和 SoC 厂商必须确保 bootloader 已经按照要求实现了 bootcontrol hal 所需要的接口，这也是为什么 Google 的 boot control hal 我们没有办法直接用，因为这个跟 OEM 和 SoC 都有一定的关系，所以我们从 CAF ( 现在改名叫 CLO 了 ) 导入这个包含了高通特有修改的 bootctl 和 gpt-utils</p>
<p>这一条 commit 对于使用 A&#x2F;B 系统更新的设备来说直接 pick 就好</p>
<h2 id="Build-Flags"><a href="#Build-Flags" class="headerlink" title="Build Flags"></a>Build Flags</h2><p>这些 Build 过程中起作用标志位主要是为了打开一些编译系统默认已经弃用的功能，不想那么麻烦的话一股脑打开就好</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># Build</span><br>BUILD_BROKEN_DUP_RULES := true<br>BUILD_BROKEN_ELF_PREBUILT_PRODUCT_COPY_FILES := true<br>BUILD_BROKEN_VENDOR_PROPERTY_NAMESPACE := true<br>BUILD_BROKEN_MISSING_REQUIRED_MODULES := true<br>BUILD_BROKEN_ENFORCE_SYSPROP_OWNER := true<br></code></pre></td></tr></table></figure>

<h2 id="IMS-amp-amp-Telephony"><a href="#IMS-amp-amp-Telephony" class="headerlink" title="IMS &amp;&amp; Telephony"></a>IMS &amp;&amp; Telephony</h2><blockquote>
<p><code>e6d415f thyme: Compile IMS &amp; Telephony packages</code></p>
</blockquote>
<p>这一条 commit 里的内容包含了编译 <code>IMS</code> 和 <code>Telephony</code> 功能的包，<code>IMS</code> 通常跟 VOLTE 有关，Telephony 嘛，顾名思义，接打电话用的，高通设备 pick 这条 commit 就好</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/Crepuscular-Blog/">Home</a></li>
         
          <li><a href="/Crepuscular-Blog/about/">About</a></li>
         
          <li><a href="/Crepuscular-Blog/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/EndCredits">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">它们有什么用?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">后续工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89-blobs"><span class="toc-number">4.</span> <span class="toc-text">私有 blobs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vbmeta-%E4%B8%8E-dtbo"><span class="toc-number">5.</span> <span class="toc-text">vbmeta 与 dtbo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SELinux"><span class="toc-number">6.</span> <span class="toc-text">SELinux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VINTF"><span class="toc-number">7.</span> <span class="toc-text">VINTF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BootControl-HAL"><span class="toc-number">8.</span> <span class="toc-text">BootControl HAL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Build-Flags"><span class="toc-number">9.</span> <span class="toc-text">Build Flags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IMS-amp-amp-Telephony"><span class="toc-number">10.</span> <span class="toc-text">IMS &amp;&amp; Telephony</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&text=凛凛的ROM课堂 -- 笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&is_video=false&description=凛凛的ROM课堂 -- 笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=凛凛的ROM课堂 -- 笔记&body=Check out this article: https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&title=凛凛的ROM课堂 -- 笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&name=凛凛的ROM课堂 -- 笔记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://endcredits.github.io/Crepuscular-Blog/post/%E5%87%9B%E5%87%9B%E7%9A%84ROM%E8%AF%BE%E5%A0%82-%E7%AC%94%E8%AE%B0.html&t=凛凛的ROM课堂 -- 笔记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2022
    Crepuscular Hans
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/Crepuscular-Blog/">Home</a></li><!--
     --><!--
       --><li><a href="/Crepuscular-Blog/about/">About</a></li><!--
     --><!--
       --><li><a href="/Crepuscular-Blog/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/EndCredits">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/Crepuscular-Blog/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
